{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  defaultContainer\n} = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\nconst {\n  TrimType\n} = require('./trim-types');\nclass ExtractorTrim {\n  constructor() {\n    let container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultContainer;\n    this.container = container.container || container;\n    this.name = 'extract-trim';\n  }\n  mustSkip(word, condition) {\n    if (condition.options && condition.options.skip && condition.options.skip.length > 0) {\n      for (let i = 0; i < condition.options.skip.length; i += 1) {\n        const skipWord = condition.options.skip[i];\n        if (condition.options.caseSensitive) {\n          if (skipWord === word) {\n            return true;\n          }\n        } else if (skipWord.toLowerCase() === word.toLowerCase()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  matchBetween(utterance, condition, name) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = condition.regex.exec(` ${utterance} `);\n      if (match) {\n        let matchIndex;\n        let startIndex;\n        let endIndex;\n        if (condition && condition.options && condition.options.closest) {\n          matchIndex = 1;\n          const leftWordIndex = match[0].indexOf(match[matchIndex]);\n          startIndex = match.index - 1 + leftWordIndex;\n          endIndex = startIndex + match[matchIndex].length - 1;\n        } else {\n          matchIndex = 0;\n          startIndex = match.index - 1;\n          endIndex = condition.regex.lastIndex - 2;\n        }\n        result.push({\n          type: 'trim',\n          subtype: TrimType.Between,\n          start: startIndex,\n          end: endIndex,\n          len: match[matchIndex].length,\n          accuracy: 1,\n          sourceText: match[matchIndex],\n          utteranceText: match[matchIndex],\n          entity: name\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n  findWord(utterance, word) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let noSpaces = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const result = [];\n    let matchFound;\n    const regex = new RegExp(noSpaces ? word : ` ${word} | ${word}|${word} `, caseSensitive ? 'g' : 'ig');\n    do {\n      const match = regex.exec(utterance);\n      if (match) {\n        result.push({\n          start: match.index,\n          end: regex.lastIndex\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n  getBeforeResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = 0;\n    for (let i = 0; i < wordPositions.length; i += 1) {\n      endPos = wordPositions[i].start;\n      const text = utterance.substring(startPos, endPos);\n      result.push({\n        type: 'trim',\n        subtype: TrimType.Before,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name\n      });\n      startPos = wordPositions[i].end;\n    }\n    return result;\n  }\n  getBeforeFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[0].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getBeforeLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[wordPositions.length - 1].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getAfterResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = utterance.length;\n    for (let i = wordPositions.length - 1; i >= 0; i -= 1) {\n      startPos = wordPositions[i].end;\n      const text = utterance.substring(startPos, endPos);\n      result.unshift({\n        type: 'trim',\n        subtype: TrimType.After,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name\n      });\n      endPos = wordPositions[i].start;\n    }\n    return result;\n  }\n  getAfterFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[0].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getAfterLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[wordPositions.length - 1].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name\n    });\n    return result;\n  }\n  getResults(utterance, wordPositions, type, name) {\n    switch (type) {\n      case TrimType.Before:\n        return this.getBeforeResults(utterance, wordPositions, name);\n      case TrimType.BeforeFirst:\n        return this.getBeforeFirstResults(utterance, wordPositions, name);\n      case TrimType.BeforeLast:\n        return this.getBeforeLastResults(utterance, wordPositions, name);\n      case TrimType.After:\n        return this.getAfterResults(utterance, wordPositions, name);\n      case TrimType.AfterFirst:\n        return this.getAfterFirstResults(utterance, wordPositions, name);\n      case TrimType.AfterLast:\n        return this.getAfterLastResults(utterance, wordPositions, name);\n      default:\n        return [];\n    }\n  }\n  match(utterance, condition, type, name) {\n    const result = [];\n    if (condition && Array.isArray(condition.words)) {\n      for (let i = 0; i < condition.words.length; i += 1) {\n        const word = condition.options.noSpaces ? condition.words[i] : ` ${condition.words[i]}`;\n        const wordPositions = this.findWord(utterance, word);\n        if (!condition.options.noSpaces) {\n          const wordPositions2 = this.findWord(utterance, condition.words[i]);\n          if (wordPositions2.length > 0 && wordPositions2[0].start === 0) {\n            wordPositions.unshift(wordPositions2[0]);\n          }\n        }\n        if (wordPositions.length > 0) {\n          result.push(...this.getResults(utterance, wordPositions, type, name));\n        }\n      }\n    }\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n  extractFromRule(utterance, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      if (current.type === TrimType.Between) {\n        edges.push(...this.matchBetween(utterance, current, rule.name));\n      } else {\n        edges.push(...this.match(utterance, current, current.type, rule.name));\n      }\n    }\n    return edges;\n  }\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(input.text || input.utterance, rules[i]);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-trim-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\nmodule.exports = ExtractorTrim;","map":{"version":3,"names":["defaultContainer","require","reduceEdges","TrimType","ExtractorTrim","constructor","container","arguments","length","undefined","name","mustSkip","word","condition","options","skip","i","skipWord","caseSensitive","toLowerCase","matchBetween","utterance","result","matchFound","match","regex","exec","matchIndex","startIndex","endIndex","closest","leftWordIndex","indexOf","index","lastIndex","push","type","subtype","Between","start","end","len","accuracy","sourceText","utteranceText","entity","filteredResult","findWord","noSpaces","RegExp","getBeforeResults","wordPositions","startPos","endPos","text","substring","Before","getBeforeFirstResults","BeforeFirst","getBeforeLastResults","BeforeLast","getAfterResults","unshift","After","getAfterFirstResults","AfterFirst","getAfterLastResults","AfterLast","getResults","Array","isArray","words","wordPositions2","getRules","input","allRules","nerRules","extractFromRule","rule","edges","rules","current","extract","srcInput","newEdges","j","sort","a","b","run","locale","extractor","get","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/ner/src/extractor-trim.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { defaultContainer } = require('@nlpjs/core');\nconst reduceEdges = require('./reduce-edges');\nconst { TrimType } = require('./trim-types');\n\nclass ExtractorTrim {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-trim';\n  }\n\n  mustSkip(word, condition) {\n    if (\n      condition.options &&\n      condition.options.skip &&\n      condition.options.skip.length > 0\n    ) {\n      for (let i = 0; i < condition.options.skip.length; i += 1) {\n        const skipWord = condition.options.skip[i];\n        if (condition.options.caseSensitive) {\n          if (skipWord === word) {\n            return true;\n          }\n        } else if (skipWord.toLowerCase() === word.toLowerCase()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  matchBetween(utterance, condition, name) {\n    const result = [];\n    let matchFound;\n    do {\n      const match = condition.regex.exec(` ${utterance} `);\n      if (match) {\n        let matchIndex;\n        let startIndex;\n        let endIndex;\n        if (condition && condition.options && condition.options.closest) {\n          matchIndex = 1;\n          const leftWordIndex = match[0].indexOf(match[matchIndex]);\n          startIndex = match.index - 1 + leftWordIndex;\n          endIndex = startIndex + match[matchIndex].length - 1;\n        } else {\n          matchIndex = 0;\n          startIndex = match.index - 1;\n          endIndex = condition.regex.lastIndex - 2;\n        }\n        result.push({\n          type: 'trim',\n          subtype: TrimType.Between,\n          start: startIndex,\n          end: endIndex,\n          len: match[matchIndex].length,\n          accuracy: 1,\n          sourceText: match[matchIndex],\n          utteranceText: match[matchIndex],\n          entity: name,\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n\n  findWord(utterance, word, caseSensitive = false, noSpaces = false) {\n    const result = [];\n    let matchFound;\n    const regex = new RegExp(\n      noSpaces ? word : ` ${word} | ${word}|${word} `,\n      caseSensitive ? 'g' : 'ig'\n    );\n    do {\n      const match = regex.exec(utterance);\n      if (match) {\n        result.push({\n          start: match.index,\n          end: regex.lastIndex,\n        });\n        matchFound = true;\n      } else {\n        matchFound = false;\n      }\n    } while (matchFound);\n    return result;\n  }\n\n  getBeforeResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = 0;\n    for (let i = 0; i < wordPositions.length; i += 1) {\n      endPos = wordPositions[i].start;\n      const text = utterance.substring(startPos, endPos);\n      result.push({\n        type: 'trim',\n        subtype: TrimType.Before,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name,\n      });\n      startPos = wordPositions[i].end;\n    }\n    return result;\n  }\n\n  getBeforeFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[0].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getBeforeLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = 0;\n    const endPos = wordPositions[wordPositions.length - 1].start;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.BeforeLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getAfterResults(utterance, wordPositions, name) {\n    const result = [];\n    let startPos = 0;\n    let endPos = utterance.length;\n    for (let i = wordPositions.length - 1; i >= 0; i -= 1) {\n      startPos = wordPositions[i].end;\n      const text = utterance.substring(startPos, endPos);\n      result.unshift({\n        type: 'trim',\n        subtype: TrimType.After,\n        start: startPos,\n        end: endPos - 1,\n        len: text.length,\n        accuracy: 0.99,\n        sourceText: text,\n        utteranceText: text,\n        entity: name,\n      });\n      endPos = wordPositions[i].start;\n    }\n    return result;\n  }\n\n  getAfterFirstResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[0].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterFirst,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getAfterLastResults(utterance, wordPositions, name) {\n    const result = [];\n    const startPos = wordPositions[wordPositions.length - 1].end;\n    const endPos = utterance.length;\n    const text = utterance.substring(startPos, endPos);\n    result.push({\n      type: 'trim',\n      subtype: TrimType.AfterLast,\n      start: startPos,\n      end: endPos - 1,\n      len: text.length,\n      accuracy: 0.99,\n      sourceText: text,\n      utteranceText: text,\n      entity: name,\n    });\n    return result;\n  }\n\n  getResults(utterance, wordPositions, type, name) {\n    switch (type) {\n      case TrimType.Before:\n        return this.getBeforeResults(utterance, wordPositions, name);\n      case TrimType.BeforeFirst:\n        return this.getBeforeFirstResults(utterance, wordPositions, name);\n      case TrimType.BeforeLast:\n        return this.getBeforeLastResults(utterance, wordPositions, name);\n      case TrimType.After:\n        return this.getAfterResults(utterance, wordPositions, name);\n      case TrimType.AfterFirst:\n        return this.getAfterFirstResults(utterance, wordPositions, name);\n      case TrimType.AfterLast:\n        return this.getAfterLastResults(utterance, wordPositions, name);\n      default:\n        return [];\n    }\n  }\n\n  match(utterance, condition, type, name) {\n    const result = [];\n    if (condition && Array.isArray(condition.words)) {\n      for (let i = 0; i < condition.words.length; i += 1) {\n        const word = condition.options.noSpaces\n          ? condition.words[i]\n          : ` ${condition.words[i]}`;\n        const wordPositions = this.findWord(utterance, word);\n        if (!condition.options.noSpaces) {\n          const wordPositions2 = this.findWord(utterance, condition.words[i]);\n          if (wordPositions2.length > 0 && wordPositions2[0].start === 0) {\n            wordPositions.unshift(wordPositions2[0]);\n          }\n        }\n        if (wordPositions.length > 0) {\n          result.push(...this.getResults(utterance, wordPositions, type, name));\n        }\n      }\n    }\n    const filteredResult = [];\n    for (let i = 0; i < result.length; i += 1) {\n      if (!this.mustSkip(result[i].utteranceText, condition)) {\n        filteredResult.push(result[i]);\n      }\n    }\n    return filteredResult;\n  }\n\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n\n  extractFromRule(utterance, rule) {\n    const edges = [];\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      if (current.type === TrimType.Between) {\n        edges.push(...this.matchBetween(utterance, current, rule.name));\n      } else {\n        edges.push(...this.match(utterance, current, current.type, rule.name));\n      }\n    }\n    return edges;\n  }\n\n  extract(srcInput) {\n    const input = srcInput;\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(\n        input.text || input.utterance,\n        rules[i]\n      );\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-trim-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\n\nmodule.exports = ExtractorTrim;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}