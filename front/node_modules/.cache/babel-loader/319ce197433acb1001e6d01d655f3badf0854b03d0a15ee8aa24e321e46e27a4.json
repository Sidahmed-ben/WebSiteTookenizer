{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar through = require('through');\nvar Decoder = require('string_decoder').StringDecoder;\nmodule.exports = split;\n\n//TODO pass in a function to map across the lines.\n\nfunction split(matcher, mapper, options) {\n  var decoder = new Decoder();\n  var soFar = '';\n  var maxLength = options && options.maxLength;\n  var trailing = options && options.trailing === false ? false : true;\n  if ('function' === typeof matcher) mapper = matcher, matcher = null;\n  if (!matcher) matcher = /\\r?\\n/;\n  function emit(stream, piece) {\n    if (mapper) {\n      try {\n        piece = mapper(piece);\n      } catch (err) {\n        return stream.emit('error', err);\n      }\n      if ('undefined' !== typeof piece) stream.queue(piece);\n    } else stream.queue(piece);\n  }\n  function next(stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher);\n    soFar = pieces.pop();\n    if (maxLength && soFar.length > maxLength) return stream.emit('error', new Error('maximum buffer reached'));\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      emit(stream, piece);\n    }\n  }\n  return through(function (b) {\n    next(this, decoder.write(b));\n  }, function () {\n    if (decoder.end) next(this, decoder.end());\n    if (trailing && soFar != null) emit(this, soFar);\n    this.queue(null);\n  });\n}","map":{"version":3,"names":["through","require","Decoder","StringDecoder","module","exports","split","matcher","mapper","options","decoder","soFar","maxLength","trailing","emit","stream","piece","err","queue","next","buffer","pieces","pop","length","Error","i","b","write","end"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/split/index.js"],"sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar through = require('through')\nvar Decoder = require('string_decoder').StringDecoder\n\nmodule.exports = split\n\n//TODO pass in a function to map across the lines.\n\nfunction split (matcher, mapper, options) {\n  var decoder = new Decoder()\n  var soFar = ''\n  var maxLength = options && options.maxLength;\n  var trailing = options && options.trailing === false ? false : true\n  if('function' === typeof matcher)\n    mapper = matcher, matcher = null\n  if (!matcher)\n    matcher = /\\r?\\n/\n\n  function emit(stream, piece) {\n    if(mapper) {\n      try {\n        piece = mapper(piece)\n      }\n      catch (err) {\n        return stream.emit('error', err)\n      }\n      if('undefined' !== typeof piece)\n        stream.queue(piece)\n    }\n    else\n      stream.queue(piece)\n  }\n\n  function next (stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    if (maxLength && soFar.length > maxLength)\n      return stream.emit('error', new Error('maximum buffer reached'))\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i]\n      emit(stream, piece)\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b))\n  },\n  function () {\n    if(decoder.end)\n      next(this, decoder.end())\n    if(trailing && soFar != null)\n      emit(this, soFar)\n    this.queue(null)\n  })\n}\n"],"mappings":"AAAA;;AAEA;AACA;AACA;;AAGA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAgB,CAAC,CAACE,aAAa;AAErDC,MAAM,CAACC,OAAO,GAAGC,KAAK;;AAEtB;;AAEA,SAASA,KAAKA,CAAEC,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAE;EACxC,IAAIC,OAAO,GAAG,IAAIR,OAAO,EAAE;EAC3B,IAAIS,KAAK,GAAG,EAAE;EACd,IAAIC,SAAS,GAAGH,OAAO,IAAIA,OAAO,CAACG,SAAS;EAC5C,IAAIC,QAAQ,GAAGJ,OAAO,IAAIA,OAAO,CAACI,QAAQ,KAAK,KAAK,GAAG,KAAK,GAAG,IAAI;EACnE,IAAG,UAAU,KAAK,OAAON,OAAO,EAC9BC,MAAM,GAAGD,OAAO,EAAEA,OAAO,GAAG,IAAI;EAClC,IAAI,CAACA,OAAO,EACVA,OAAO,GAAG,OAAO;EAEnB,SAASO,IAAIA,CAACC,MAAM,EAAEC,KAAK,EAAE;IAC3B,IAAGR,MAAM,EAAE;MACT,IAAI;QACFQ,KAAK,GAAGR,MAAM,CAACQ,KAAK,CAAC;MACvB,CAAC,CACD,OAAOC,GAAG,EAAE;QACV,OAAOF,MAAM,CAACD,IAAI,CAAC,OAAO,EAAEG,GAAG,CAAC;MAClC;MACA,IAAG,WAAW,KAAK,OAAOD,KAAK,EAC7BD,MAAM,CAACG,KAAK,CAACF,KAAK,CAAC;IACvB,CAAC,MAECD,MAAM,CAACG,KAAK,CAACF,KAAK,CAAC;EACvB;EAEA,SAASG,IAAIA,CAAEJ,MAAM,EAAEK,MAAM,EAAE;IAC7B,IAAIC,MAAM,GAAG,CAAC,CAACV,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAG,EAAE,IAAIS,MAAM,EAAEd,KAAK,CAACC,OAAO,CAAC;IACnEI,KAAK,GAAGU,MAAM,CAACC,GAAG,EAAE;IAEpB,IAAIV,SAAS,IAAID,KAAK,CAACY,MAAM,GAAGX,SAAS,EACvC,OAAOG,MAAM,CAACD,IAAI,CAAC,OAAO,EAAE,IAAIU,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAElE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACE,MAAM,EAAEE,CAAC,EAAE,EAAE;MACtC,IAAIT,KAAK,GAAGK,MAAM,CAACI,CAAC,CAAC;MACrBX,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;IACrB;EACF;EAEA,OAAOhB,OAAO,CAAC,UAAU0B,CAAC,EAAE;IAC1BP,IAAI,CAAC,IAAI,EAAET,OAAO,CAACiB,KAAK,CAACD,CAAC,CAAC,CAAC;EAC9B,CAAC,EACD,YAAY;IACV,IAAGhB,OAAO,CAACkB,GAAG,EACZT,IAAI,CAAC,IAAI,EAAET,OAAO,CAACkB,GAAG,EAAE,CAAC;IAC3B,IAAGf,QAAQ,IAAIF,KAAK,IAAI,IAAI,EAC1BG,IAAI,CAAC,IAAI,EAAEH,KAAK,CAAC;IACnB,IAAI,CAACO,KAAK,CAAC,IAAI,CAAC;EAClB,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}