{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst {\n  TrimTypesList\n} = require('./trim-types');\nfunction runDiscard(srcEdge, srcOther, useMaxLength) {\n  let edge;\n  let other;\n  if (srcEdge.accuracy > srcOther.accuracy || srcEdge.accuracy === srcOther.accuracy && srcEdge.length > srcOther.length) {\n    edge = srcEdge;\n    other = srcOther;\n  } else {\n    edge = srcOther;\n    other = srcEdge;\n  }\n  if (other.start <= edge.end && other.end >= edge.start) {\n    if (other.accuracy < edge.accuracy) {\n      other.discarded = true;\n    } else if ((useMaxLength || other.entity === edge.entity || other.entity === 'number') && other.len <= edge.len) {\n      // Do nothing! entities have same priority\n      if (other.start === edge.start && other.end === edge.end && other.type === edge.type && other.entity === edge.entity && other.option === edge.option) {\n        other.discarded = true;\n      }\n    } else if ((useMaxLength || other.entity === edge.entity || edge.entity === 'number') && other.len > edge.len) {\n      edge.discarded = true;\n    } else if (edge.type === 'enum' && other.type === 'enum') {\n      if (edge.len <= other.len && other.utteranceText.includes(edge.utteranceText)) {\n        edge.discarded = true;\n      } else if (edge.len > other.len && edge.utteranceText.includes(other.utteranceText)) {\n        other.discarded = true;\n      }\n    }\n  }\n}\n\n/**\n * Given an array of edges, detect the trim edges and find overlaps with\n * non-trim edges. When an overlap is detected, reduce the trim edged to\n * fit with the other edge. Only cases where it overlaps on beginning or\n * end are handled\n * @param {Object[]} edges Edges to be splitted\n * @returns {Object[]} Splitted edges.\n */\nfunction splitEdges(edges) {\n  for (let i = 0, l = edges.length; i < l; i += 1) {\n    const edge = edges[i];\n    if (edge.type === 'trim' && TrimTypesList.includes(edge.subtype)) {\n      for (let j = 0; j < edges.length; j += 1) {\n        const other = edges[j];\n        if (i !== j && other.start >= edge.start && other.end <= edge.end && other.type !== 'trim') {\n          const edgeLen = edge.end - edge.start;\n          const otherLen = other.end - other.start;\n          if (edge.end === other.end) {\n            // is at the end\n            const text = edge.sourceText.substring(0, edgeLen - otherLen - 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.end = other.start - 1;\n            edge.len = text.length;\n          } else if (edge.start === other.start) {\n            // is at the start\n            const text = edge.sourceText.substring(otherLen + 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.start = other.end + 1;\n            edge.len = text.length;\n          }\n        }\n      }\n    }\n  }\n  return edges;\n}\nfunction reduceEdges(edges) {\n  let useMaxLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  edges = splitEdges(edges);\n  const edgeslen = edges.length;\n  for (let i = 0; i < edgeslen; i += 1) {\n    const edge = edges[i];\n    if (edge.len === 0) {\n      edge.discarded = true;\n    }\n    if (!edge.discarded) {\n      for (let j = i + 1; j < edgeslen; j += 1) {\n        const other = edges[j];\n        if (!other.discarded) {\n          runDiscard(edge, other, useMaxLength);\n        }\n      }\n    }\n  }\n  return edges.filter(x => !x.discarded);\n}\nmodule.exports = reduceEdges;","map":{"version":3,"names":["TrimTypesList","require","runDiscard","srcEdge","srcOther","useMaxLength","edge","other","accuracy","length","start","end","discarded","entity","len","type","option","utteranceText","includes","splitEdges","edges","i","l","subtype","j","edgeLen","otherLen","text","sourceText","substring","reduceEdges","arguments","undefined","edgeslen","filter","x","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/ner/src/reduce-edges.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst { TrimTypesList } = require('./trim-types');\n\nfunction runDiscard(srcEdge, srcOther, useMaxLength) {\n  let edge;\n  let other;\n  if (\n    srcEdge.accuracy > srcOther.accuracy ||\n    (srcEdge.accuracy === srcOther.accuracy && srcEdge.length > srcOther.length)\n  ) {\n    edge = srcEdge;\n    other = srcOther;\n  } else {\n    edge = srcOther;\n    other = srcEdge;\n  }\n  if (other.start <= edge.end && other.end >= edge.start) {\n    if (other.accuracy < edge.accuracy) {\n      other.discarded = true;\n    } else if (\n      (useMaxLength ||\n        other.entity === edge.entity ||\n        other.entity === 'number') &&\n      other.len <= edge.len\n    ) {\n      // Do nothing! entities have same priority\n      if (\n        other.start === edge.start &&\n        other.end === edge.end &&\n        other.type === edge.type &&\n        other.entity === edge.entity &&\n        other.option === edge.option\n      ) {\n        other.discarded = true;\n      }\n    } else if (\n      (useMaxLength ||\n        other.entity === edge.entity ||\n        edge.entity === 'number') &&\n      other.len > edge.len\n    ) {\n      edge.discarded = true;\n    } else if (edge.type === 'enum' && other.type === 'enum') {\n      if (\n        edge.len <= other.len &&\n        other.utteranceText.includes(edge.utteranceText)\n      ) {\n        edge.discarded = true;\n      } else if (\n        edge.len > other.len &&\n        edge.utteranceText.includes(other.utteranceText)\n      ) {\n        other.discarded = true;\n      }\n    }\n  }\n}\n\n/**\n * Given an array of edges, detect the trim edges and find overlaps with\n * non-trim edges. When an overlap is detected, reduce the trim edged to\n * fit with the other edge. Only cases where it overlaps on beginning or\n * end are handled\n * @param {Object[]} edges Edges to be splitted\n * @returns {Object[]} Splitted edges.\n */\nfunction splitEdges(edges) {\n  for (let i = 0, l = edges.length; i < l; i += 1) {\n    const edge = edges[i];\n    if (edge.type === 'trim' && TrimTypesList.includes(edge.subtype)) {\n      for (let j = 0; j < edges.length; j += 1) {\n        const other = edges[j];\n        if (\n          i !== j &&\n          other.start >= edge.start &&\n          other.end <= edge.end &&\n          other.type !== 'trim'\n        ) {\n          const edgeLen = edge.end - edge.start;\n          const otherLen = other.end - other.start;\n          if (edge.end === other.end) {\n            // is at the end\n            const text = edge.sourceText.substring(0, edgeLen - otherLen - 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.end = other.start - 1;\n            edge.len = text.length;\n          } else if (edge.start === other.start) {\n            // is at the start\n            const text = edge.sourceText.substring(otherLen + 1);\n            edge.sourceText = text;\n            edge.utteranceText = text;\n            edge.start = other.end + 1;\n            edge.len = text.length;\n          }\n        }\n      }\n    }\n  }\n  return edges;\n}\n\nfunction reduceEdges(edges, useMaxLength = true) {\n  edges = splitEdges(edges);\n  const edgeslen = edges.length;\n  for (let i = 0; i < edgeslen; i += 1) {\n    const edge = edges[i];\n    if (edge.len === 0) {\n      edge.discarded = true;\n    }\n    if (!edge.discarded) {\n      for (let j = i + 1; j < edgeslen; j += 1) {\n        const other = edges[j];\n        if (!other.discarded) {\n          runDiscard(edge, other, useMaxLength);\n        }\n      }\n    }\n  }\n  return edges.filter((x) => !x.discarded);\n}\n\nmodule.exports = reduceEdges;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EAAEA;AAAc,CAAC,GAAGC,OAAO,CAAC,cAAc,CAAC;AAEjD,SAASC,UAAUA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,YAAY,EAAE;EACnD,IAAIC,IAAI;EACR,IAAIC,KAAK;EACT,IACEJ,OAAO,CAACK,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ,IACnCL,OAAO,CAACK,QAAQ,KAAKJ,QAAQ,CAACI,QAAQ,IAAIL,OAAO,CAACM,MAAM,GAAGL,QAAQ,CAACK,MAAO,EAC5E;IACAH,IAAI,GAAGH,OAAO;IACdI,KAAK,GAAGH,QAAQ;EAClB,CAAC,MAAM;IACLE,IAAI,GAAGF,QAAQ;IACfG,KAAK,GAAGJ,OAAO;EACjB;EACA,IAAII,KAAK,CAACG,KAAK,IAAIJ,IAAI,CAACK,GAAG,IAAIJ,KAAK,CAACI,GAAG,IAAIL,IAAI,CAACI,KAAK,EAAE;IACtD,IAAIH,KAAK,CAACC,QAAQ,GAAGF,IAAI,CAACE,QAAQ,EAAE;MAClCD,KAAK,CAACK,SAAS,GAAG,IAAI;IACxB,CAAC,MAAM,IACL,CAACP,YAAY,IACXE,KAAK,CAACM,MAAM,KAAKP,IAAI,CAACO,MAAM,IAC5BN,KAAK,CAACM,MAAM,KAAK,QAAQ,KAC3BN,KAAK,CAACO,GAAG,IAAIR,IAAI,CAACQ,GAAG,EACrB;MACA;MACA,IACEP,KAAK,CAACG,KAAK,KAAKJ,IAAI,CAACI,KAAK,IAC1BH,KAAK,CAACI,GAAG,KAAKL,IAAI,CAACK,GAAG,IACtBJ,KAAK,CAACQ,IAAI,KAAKT,IAAI,CAACS,IAAI,IACxBR,KAAK,CAACM,MAAM,KAAKP,IAAI,CAACO,MAAM,IAC5BN,KAAK,CAACS,MAAM,KAAKV,IAAI,CAACU,MAAM,EAC5B;QACAT,KAAK,CAACK,SAAS,GAAG,IAAI;MACxB;IACF,CAAC,MAAM,IACL,CAACP,YAAY,IACXE,KAAK,CAACM,MAAM,KAAKP,IAAI,CAACO,MAAM,IAC5BP,IAAI,CAACO,MAAM,KAAK,QAAQ,KAC1BN,KAAK,CAACO,GAAG,GAAGR,IAAI,CAACQ,GAAG,EACpB;MACAR,IAAI,CAACM,SAAS,GAAG,IAAI;IACvB,CAAC,MAAM,IAAIN,IAAI,CAACS,IAAI,KAAK,MAAM,IAAIR,KAAK,CAACQ,IAAI,KAAK,MAAM,EAAE;MACxD,IACET,IAAI,CAACQ,GAAG,IAAIP,KAAK,CAACO,GAAG,IACrBP,KAAK,CAACU,aAAa,CAACC,QAAQ,CAACZ,IAAI,CAACW,aAAa,CAAC,EAChD;QACAX,IAAI,CAACM,SAAS,GAAG,IAAI;MACvB,CAAC,MAAM,IACLN,IAAI,CAACQ,GAAG,GAAGP,KAAK,CAACO,GAAG,IACpBR,IAAI,CAACW,aAAa,CAACC,QAAQ,CAACX,KAAK,CAACU,aAAa,CAAC,EAChD;QACAV,KAAK,CAACK,SAAS,GAAG,IAAI;MACxB;IACF;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,UAAUA,CAACC,KAAK,EAAE;EACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,KAAK,CAACX,MAAM,EAAEY,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;IAC/C,MAAMf,IAAI,GAAGc,KAAK,CAACC,CAAC,CAAC;IACrB,IAAIf,IAAI,CAACS,IAAI,KAAK,MAAM,IAAIf,aAAa,CAACkB,QAAQ,CAACZ,IAAI,CAACiB,OAAO,CAAC,EAAE;MAChE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACX,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMjB,KAAK,GAAGa,KAAK,CAACI,CAAC,CAAC;QACtB,IACEH,CAAC,KAAKG,CAAC,IACPjB,KAAK,CAACG,KAAK,IAAIJ,IAAI,CAACI,KAAK,IACzBH,KAAK,CAACI,GAAG,IAAIL,IAAI,CAACK,GAAG,IACrBJ,KAAK,CAACQ,IAAI,KAAK,MAAM,EACrB;UACA,MAAMU,OAAO,GAAGnB,IAAI,CAACK,GAAG,GAAGL,IAAI,CAACI,KAAK;UACrC,MAAMgB,QAAQ,GAAGnB,KAAK,CAACI,GAAG,GAAGJ,KAAK,CAACG,KAAK;UACxC,IAAIJ,IAAI,CAACK,GAAG,KAAKJ,KAAK,CAACI,GAAG,EAAE;YAC1B;YACA,MAAMgB,IAAI,GAAGrB,IAAI,CAACsB,UAAU,CAACC,SAAS,CAAC,CAAC,EAAEJ,OAAO,GAAGC,QAAQ,GAAG,CAAC,CAAC;YACjEpB,IAAI,CAACsB,UAAU,GAAGD,IAAI;YACtBrB,IAAI,CAACW,aAAa,GAAGU,IAAI;YACzBrB,IAAI,CAACK,GAAG,GAAGJ,KAAK,CAACG,KAAK,GAAG,CAAC;YAC1BJ,IAAI,CAACQ,GAAG,GAAGa,IAAI,CAAClB,MAAM;UACxB,CAAC,MAAM,IAAIH,IAAI,CAACI,KAAK,KAAKH,KAAK,CAACG,KAAK,EAAE;YACrC;YACA,MAAMiB,IAAI,GAAGrB,IAAI,CAACsB,UAAU,CAACC,SAAS,CAACH,QAAQ,GAAG,CAAC,CAAC;YACpDpB,IAAI,CAACsB,UAAU,GAAGD,IAAI;YACtBrB,IAAI,CAACW,aAAa,GAAGU,IAAI;YACzBrB,IAAI,CAACI,KAAK,GAAGH,KAAK,CAACI,GAAG,GAAG,CAAC;YAC1BL,IAAI,CAACQ,GAAG,GAAGa,IAAI,CAAClB,MAAM;UACxB;QACF;MACF;IACF;EACF;EACA,OAAOW,KAAK;AACd;AAEA,SAASU,WAAWA,CAACV,KAAK,EAAuB;EAAA,IAArBf,YAAY,GAAA0B,SAAA,CAAAtB,MAAA,QAAAsB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;EAC7CX,KAAK,GAAGD,UAAU,CAACC,KAAK,CAAC;EACzB,MAAMa,QAAQ,GAAGb,KAAK,CAACX,MAAM;EAC7B,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,QAAQ,EAAEZ,CAAC,IAAI,CAAC,EAAE;IACpC,MAAMf,IAAI,GAAGc,KAAK,CAACC,CAAC,CAAC;IACrB,IAAIf,IAAI,CAACQ,GAAG,KAAK,CAAC,EAAE;MAClBR,IAAI,CAACM,SAAS,GAAG,IAAI;IACvB;IACA,IAAI,CAACN,IAAI,CAACM,SAAS,EAAE;MACnB,KAAK,IAAIY,CAAC,GAAGH,CAAC,GAAG,CAAC,EAAEG,CAAC,GAAGS,QAAQ,EAAET,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMjB,KAAK,GAAGa,KAAK,CAACI,CAAC,CAAC;QACtB,IAAI,CAACjB,KAAK,CAACK,SAAS,EAAE;UACpBV,UAAU,CAACI,IAAI,EAAEC,KAAK,EAAEF,YAAY,CAAC;QACvC;MACF;IACF;EACF;EACA,OAAOe,KAAK,CAACc,MAAM,CAAEC,CAAC,IAAK,CAACA,CAAC,CAACvB,SAAS,CAAC;AAC1C;AAEAwB,MAAM,CAACC,OAAO,GAAGP,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}