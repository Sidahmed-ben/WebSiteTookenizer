{"ast":null,"code":"/**\n * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE\n */\n\nlet fs = require('fs');\nconst util = require('util');\nconst path = require('path');\nconst events = require('events');\nconst zlib = require('zlib');\nconst stream = require('stream');\nconst consts = {\n  /* The local file header */\n  LOCHDR: 30,\n  // LOC header size\n  LOCSIG: 0x04034b50,\n  // \"PK\\003\\004\"\n  LOCVER: 4,\n  // version needed to extract\n  LOCFLG: 6,\n  // general purpose bit flag\n  LOCHOW: 8,\n  // compression method\n  LOCTIM: 10,\n  // modification time (2 bytes time, 2 bytes date)\n  LOCCRC: 14,\n  // uncompressed file crc-32 value\n  LOCSIZ: 18,\n  // compressed size\n  LOCLEN: 22,\n  // uncompressed size\n  LOCNAM: 26,\n  // filename length\n  LOCEXT: 28,\n  // extra field length\n\n  /* The Data descriptor */\n  EXTSIG: 0x08074b50,\n  // \"PK\\007\\008\"\n  EXTHDR: 16,\n  // EXT header size\n  EXTCRC: 4,\n  // uncompressed file crc-32 value\n  EXTSIZ: 8,\n  // compressed size\n  EXTLEN: 12,\n  // uncompressed size\n\n  /* The central directory file header */\n  CENHDR: 46,\n  // CEN header size\n  CENSIG: 0x02014b50,\n  // \"PK\\001\\002\"\n  CENVEM: 4,\n  // version made by\n  CENVER: 6,\n  // version needed to extract\n  CENFLG: 8,\n  // encrypt, decrypt flags\n  CENHOW: 10,\n  // compression method\n  CENTIM: 12,\n  // modification time (2 bytes time, 2 bytes date)\n  CENCRC: 16,\n  // uncompressed file crc-32 value\n  CENSIZ: 20,\n  // compressed size\n  CENLEN: 24,\n  // uncompressed size\n  CENNAM: 28,\n  // filename length\n  CENEXT: 30,\n  // extra field length\n  CENCOM: 32,\n  // file comment length\n  CENDSK: 34,\n  // volume number start\n  CENATT: 36,\n  // internal file attributes\n  CENATX: 38,\n  // external file attributes (host system dependent)\n  CENOFF: 42,\n  // LOC header offset\n\n  /* The entries in the end of central directory */\n  ENDHDR: 22,\n  // END header size\n  ENDSIG: 0x06054b50,\n  // \"PK\\005\\006\"\n  ENDSIGFIRST: 0x50,\n  ENDSUB: 8,\n  // number of entries on this disk\n  ENDTOT: 10,\n  // total number of entries\n  ENDSIZ: 12,\n  // central directory size in bytes\n  ENDOFF: 16,\n  // offset of first CEN header\n  ENDCOM: 20,\n  // zip file comment length\n  MAXFILECOMMENT: 0xffff,\n  /* The entries in the end of ZIP64 central directory locator */\n  ENDL64HDR: 20,\n  // ZIP64 end of central directory locator header size\n  ENDL64SIG: 0x07064b50,\n  // ZIP64 end of central directory locator signature\n  ENDL64SIGFIRST: 0x50,\n  ENDL64OFS: 8,\n  // ZIP64 end of central directory offset\n\n  /* The entries in the end of ZIP64 central directory */\n  END64HDR: 56,\n  // ZIP64 end of central directory header size\n  END64SIG: 0x06064b50,\n  // ZIP64 end of central directory signature\n  END64SIGFIRST: 0x50,\n  END64SUB: 24,\n  // number of entries on this disk\n  END64TOT: 32,\n  // total number of entries\n  END64SIZ: 40,\n  END64OFF: 48,\n  /* Compression methods */\n  STORED: 0,\n  // no compression\n  SHRUNK: 1,\n  // shrunk\n  REDUCED1: 2,\n  // reduced with compression factor 1\n  REDUCED2: 3,\n  // reduced with compression factor 2\n  REDUCED3: 4,\n  // reduced with compression factor 3\n  REDUCED4: 5,\n  // reduced with compression factor 4\n  IMPLODED: 6,\n  // imploded\n  // 7 reserved\n  DEFLATED: 8,\n  // deflated\n  ENHANCED_DEFLATED: 9,\n  // deflate64\n  PKWARE: 10,\n  // PKWare DCL imploded\n  // 11 reserved\n  BZIP2: 12,\n  //  compressed using BZIP2\n  // 13 reserved\n  LZMA: 14,\n  // LZMA\n  // 15-17 reserved\n  IBM_TERSE: 18,\n  // compressed using IBM TERSE\n  IBM_LZ77: 19,\n  //IBM LZ77 z\n\n  /* General purpose bit flag */\n  FLG_ENC: 0,\n  // encrypted file\n  FLG_COMP1: 1,\n  // compression option\n  FLG_COMP2: 2,\n  // compression option\n  FLG_DESC: 4,\n  // data descriptor\n  FLG_ENH: 8,\n  // enhanced deflation\n  FLG_STR: 16,\n  // strong encryption\n  FLG_LNG: 1024,\n  // language encoding\n  FLG_MSK: 4096,\n  // mask header values\n  FLG_ENTRY_ENC: 1,\n  /* 4.5 Extensible data fields */\n  EF_ID: 0,\n  EF_SIZE: 2,\n  /* Header IDs */\n  ID_ZIP64: 0x0001,\n  ID_AVINFO: 0x0007,\n  ID_PFS: 0x0008,\n  ID_OS2: 0x0009,\n  ID_NTFS: 0x000a,\n  ID_OPENVMS: 0x000c,\n  ID_UNIX: 0x000d,\n  ID_FORK: 0x000e,\n  ID_PATCH: 0x000f,\n  ID_X509_PKCS7: 0x0014,\n  ID_X509_CERTID_F: 0x0015,\n  ID_X509_CERTID_C: 0x0016,\n  ID_STRONGENC: 0x0017,\n  ID_RECORD_MGT: 0x0018,\n  ID_X509_PKCS7_RL: 0x0019,\n  ID_IBM1: 0x0065,\n  ID_IBM2: 0x0066,\n  ID_POSZIP: 0x4690,\n  EF_ZIP64_OR_32: 0xffffffff,\n  EF_ZIP64_OR_16: 0xffff\n};\nconst StreamZip = function (config) {\n  let fd, fileSize, chunkSize, op, centralDirectory, closed;\n  const ready = false,\n    that = this,\n    entries = config.storeEntries !== false ? {} : null,\n    fileName = config.file,\n    textDecoder = config.nameEncoding ? new TextDecoder(config.nameEncoding) : null;\n  open();\n  function open() {\n    if (config.fd) {\n      fd = config.fd;\n      readFile();\n    } else {\n      fs.open(fileName, 'r', (err, f) => {\n        if (err) {\n          return that.emit('error', err);\n        }\n        fd = f;\n        readFile();\n      });\n    }\n  }\n  function readFile() {\n    fs.fstat(fd, (err, stat) => {\n      if (err) {\n        return that.emit('error', err);\n      }\n      fileSize = stat.size;\n      chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n      chunkSize = Math.max(Math.min(chunkSize, Math.min(128 * 1024, fileSize)), Math.min(1024, fileSize));\n      readCentralDirectory();\n    });\n  }\n  function readUntilFoundCallback(err, bytesRead) {\n    if (err || !bytesRead) {\n      return that.emit('error', err || new Error('Archive read error'));\n    }\n    let pos = op.lastPos;\n    let bufferPosition = pos - op.win.position;\n    const buffer = op.win.buffer;\n    const minPos = op.minPos;\n    while (--pos >= minPos && --bufferPosition >= 0) {\n      if (buffer.length - bufferPosition >= 4 && buffer[bufferPosition] === op.firstByte) {\n        // quick check first signature byte\n        if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n          op.lastBufferPosition = bufferPosition;\n          op.lastBytesRead = bytesRead;\n          op.complete();\n          return;\n        }\n      }\n    }\n    if (pos === minPos) {\n      return that.emit('error', new Error('Bad archive'));\n    }\n    op.lastPos = pos + 1;\n    op.chunkSize *= 2;\n    if (pos <= minPos) {\n      return that.emit('error', new Error('Bad archive'));\n    }\n    const expandLength = Math.min(op.chunkSize, pos - minPos);\n    op.win.expandLeft(expandLength, readUntilFoundCallback);\n  }\n  function readCentralDirectory() {\n    const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n    op = {\n      win: new FileWindowBuffer(fd),\n      totalReadLength,\n      minPos: fileSize - totalReadLength,\n      lastPos: fileSize,\n      chunkSize: Math.min(1024, chunkSize),\n      firstByte: consts.ENDSIGFIRST,\n      sig: consts.ENDSIG,\n      complete: readCentralDirectoryComplete\n    };\n    op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n  }\n  function readCentralDirectoryComplete() {\n    const buffer = op.win.buffer;\n    const pos = op.lastBufferPosition;\n    try {\n      centralDirectory = new CentralDirectoryHeader();\n      centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n      centralDirectory.headerOffset = op.win.position + pos;\n      if (centralDirectory.commentLength) {\n        that.comment = buffer.slice(pos + consts.ENDHDR, pos + consts.ENDHDR + centralDirectory.commentLength).toString();\n      } else {\n        that.comment = null;\n      }\n      that.entriesCount = centralDirectory.volumeEntries;\n      that.centralDirectory = centralDirectory;\n      if (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 && centralDirectory.totalEntries === consts.EF_ZIP64_OR_16 || centralDirectory.size === consts.EF_ZIP64_OR_32 || centralDirectory.offset === consts.EF_ZIP64_OR_32) {\n        readZip64CentralDirectoryLocator();\n      } else {\n        op = {};\n        readEntries();\n      }\n    } catch (err) {\n      that.emit('error', err);\n    }\n  }\n  function readZip64CentralDirectoryLocator() {\n    const length = consts.ENDL64HDR;\n    if (op.lastBufferPosition > length) {\n      op.lastBufferPosition -= length;\n      readZip64CentralDirectoryLocatorComplete();\n    } else {\n      op = {\n        win: op.win,\n        totalReadLength: length,\n        minPos: op.win.position - length,\n        lastPos: op.win.position,\n        chunkSize: op.chunkSize,\n        firstByte: consts.ENDL64SIGFIRST,\n        sig: consts.ENDL64SIG,\n        complete: readZip64CentralDirectoryLocatorComplete\n      };\n      op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n  }\n  function readZip64CentralDirectoryLocatorComplete() {\n    const buffer = op.win.buffer;\n    const locHeader = new CentralDirectoryLoc64Header();\n    locHeader.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR));\n    const readLength = fileSize - locHeader.headerOffset;\n    op = {\n      win: op.win,\n      totalReadLength: readLength,\n      minPos: locHeader.headerOffset,\n      lastPos: op.lastPos,\n      chunkSize: op.chunkSize,\n      firstByte: consts.END64SIGFIRST,\n      sig: consts.END64SIG,\n      complete: readZip64CentralDirectoryComplete\n    };\n    op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n  }\n  function readZip64CentralDirectoryComplete() {\n    const buffer = op.win.buffer;\n    const zip64cd = new CentralDirectoryZip64Header();\n    zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n    that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n    that.centralDirectory.totalEntries = zip64cd.totalEntries;\n    that.centralDirectory.size = zip64cd.size;\n    that.centralDirectory.offset = zip64cd.offset;\n    that.entriesCount = zip64cd.volumeEntries;\n    op = {};\n    readEntries();\n  }\n  function readEntries() {\n    op = {\n      win: new FileWindowBuffer(fd),\n      pos: centralDirectory.offset,\n      chunkSize,\n      entriesLeft: centralDirectory.volumeEntries\n    };\n    op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n  }\n  function readEntriesCallback(err, bytesRead) {\n    if (err || !bytesRead) {\n      return that.emit('error', err || new Error('Entries read error'));\n    }\n    let bufferPos = op.pos - op.win.position;\n    let entry = op.entry;\n    const buffer = op.win.buffer;\n    const bufferLength = buffer.length;\n    try {\n      while (op.entriesLeft > 0) {\n        if (!entry) {\n          entry = new ZipEntry();\n          entry.readHeader(buffer, bufferPos);\n          entry.headerOffset = op.win.position + bufferPos;\n          op.entry = entry;\n          op.pos += consts.CENHDR;\n          bufferPos += consts.CENHDR;\n        }\n        const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n        const advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n        if (bufferLength - bufferPos < advanceBytes) {\n          op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n          op.move = true;\n          return;\n        }\n        entry.read(buffer, bufferPos, textDecoder);\n        if (!config.skipEntryNameValidation) {\n          entry.validateName();\n        }\n        if (entries) {\n          entries[entry.name] = entry;\n        }\n        that.emit('entry', entry);\n        op.entry = entry = null;\n        op.entriesLeft--;\n        op.pos += entryHeaderSize;\n        bufferPos += entryHeaderSize;\n      }\n      that.emit('ready');\n    } catch (err) {\n      that.emit('error', err);\n    }\n  }\n  function checkEntriesExist() {\n    if (!entries) {\n      throw new Error('storeEntries disabled');\n    }\n  }\n  Object.defineProperty(this, 'ready', {\n    get() {\n      return ready;\n    }\n  });\n  this.entry = function (name) {\n    checkEntriesExist();\n    return entries[name];\n  };\n  this.entries = function () {\n    checkEntriesExist();\n    return entries;\n  };\n  this.stream = function (entry, callback) {\n    return this.openEntry(entry, (err, entry) => {\n      if (err) {\n        return callback(err);\n      }\n      const offset = dataOffset(entry);\n      let entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n      if (entry.method === consts.STORED) {\n        // nothing to do\n      } else if (entry.method === consts.DEFLATED) {\n        entryStream = entryStream.pipe(zlib.createInflateRaw());\n      } else {\n        return callback(new Error('Unknown compression method: ' + entry.method));\n      }\n      if (canVerifyCrc(entry)) {\n        entryStream = entryStream.pipe(new EntryVerifyStream(entryStream, entry.crc, entry.size));\n      }\n      callback(null, entryStream);\n    }, false);\n  };\n  this.entryDataSync = function (entry) {\n    let err = null;\n    this.openEntry(entry, (e, en) => {\n      err = e;\n      entry = en;\n    }, true);\n    if (err) {\n      throw err;\n    }\n    let data = Buffer.alloc(entry.compressedSize);\n    new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), e => {\n      err = e;\n    }).read(true);\n    if (err) {\n      throw err;\n    }\n    if (entry.method === consts.STORED) {\n      // nothing to do\n    } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n      data = zlib.inflateRawSync(data);\n    } else {\n      throw new Error('Unknown compression method: ' + entry.method);\n    }\n    if (data.length !== entry.size) {\n      throw new Error('Invalid size');\n    }\n    if (canVerifyCrc(entry)) {\n      const verify = new CrcVerify(entry.crc, entry.size);\n      verify.data(data);\n    }\n    return data;\n  };\n  this.openEntry = function (entry, callback, sync) {\n    if (typeof entry === 'string') {\n      checkEntriesExist();\n      entry = entries[entry];\n      if (!entry) {\n        return callback(new Error('Entry not found'));\n      }\n    }\n    if (!entry.isFile) {\n      return callback(new Error('Entry is not file'));\n    }\n    if (!fd) {\n      return callback(new Error('Archive closed'));\n    }\n    const buffer = Buffer.alloc(consts.LOCHDR);\n    new FsRead(fd, buffer, 0, buffer.length, entry.offset, err => {\n      if (err) {\n        return callback(err);\n      }\n      let readEx;\n      try {\n        entry.readDataHeader(buffer);\n        if (entry.encrypted) {\n          readEx = new Error('Entry encrypted');\n        }\n      } catch (ex) {\n        readEx = ex;\n      }\n      callback(readEx, entry);\n    }).read(sync);\n  };\n  function dataOffset(entry) {\n    return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n  }\n  function canVerifyCrc(entry) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    return (entry.flags & 0x8) !== 0x8;\n  }\n  function extract(entry, outPath, callback) {\n    that.stream(entry, (err, stm) => {\n      if (err) {\n        callback(err);\n      } else {\n        let fsStm, errThrown;\n        stm.on('error', err => {\n          errThrown = err;\n          if (fsStm) {\n            stm.unpipe(fsStm);\n            fsStm.close(() => {\n              callback(err);\n            });\n          }\n        });\n        fs.open(outPath, 'w', (err, fdFile) => {\n          if (err) {\n            return callback(err);\n          }\n          if (errThrown) {\n            fs.close(fd, () => {\n              callback(errThrown);\n            });\n            return;\n          }\n          fsStm = fs.createWriteStream(outPath, {\n            fd: fdFile\n          });\n          fsStm.on('finish', () => {\n            that.emit('extract', entry, outPath);\n            if (!errThrown) {\n              callback();\n            }\n          });\n          stm.pipe(fsStm);\n        });\n      }\n    });\n  }\n  function createDirectories(baseDir, dirs, callback) {\n    if (!dirs.length) {\n      return callback();\n    }\n    let dir = dirs.shift();\n    dir = path.join(baseDir, path.join(...dir));\n    fs.mkdir(dir, {\n      recursive: true\n    }, err => {\n      if (err && err.code !== 'EEXIST') {\n        return callback(err);\n      }\n      createDirectories(baseDir, dirs, callback);\n    });\n  }\n  function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n    if (!files.length) {\n      return callback(null, extractedCount);\n    }\n    const file = files.shift();\n    const targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n    extract(file, targetPath, err => {\n      if (err) {\n        return callback(err, extractedCount);\n      }\n      extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n    });\n  }\n  this.extract = function (entry, outPath, callback) {\n    let entryName = entry || '';\n    if (typeof entry === 'string') {\n      entry = this.entry(entry);\n      if (entry) {\n        entryName = entry.name;\n      } else {\n        if (entryName.length && entryName[entryName.length - 1] !== '/') {\n          entryName += '/';\n        }\n      }\n    }\n    if (!entry || entry.isDirectory) {\n      const files = [],\n        dirs = [],\n        allDirs = {};\n      for (const e in entries) {\n        if (Object.prototype.hasOwnProperty.call(entries, e) && e.lastIndexOf(entryName, 0) === 0) {\n          let relPath = e.replace(entryName, '');\n          const childEntry = entries[e];\n          if (childEntry.isFile) {\n            files.push(childEntry);\n            relPath = path.dirname(relPath);\n          }\n          if (relPath && !allDirs[relPath] && relPath !== '.') {\n            allDirs[relPath] = true;\n            let parts = relPath.split('/').filter(f => {\n              return f;\n            });\n            if (parts.length) {\n              dirs.push(parts);\n            }\n            while (parts.length > 1) {\n              parts = parts.slice(0, parts.length - 1);\n              const partsPath = parts.join('/');\n              if (allDirs[partsPath] || partsPath === '.') {\n                break;\n              }\n              allDirs[partsPath] = true;\n              dirs.push(parts);\n            }\n          }\n        }\n      }\n      dirs.sort((x, y) => {\n        return x.length - y.length;\n      });\n      if (dirs.length) {\n        createDirectories(outPath, dirs, err => {\n          if (err) {\n            callback(err);\n          } else {\n            extractFiles(outPath, entryName, files, callback, 0);\n          }\n        });\n      } else {\n        extractFiles(outPath, entryName, files, callback, 0);\n      }\n    } else {\n      fs.stat(outPath, (err, stat) => {\n        if (stat && stat.isDirectory()) {\n          extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n        } else {\n          extract(entry, outPath, callback);\n        }\n      });\n    }\n  };\n  this.close = function (callback) {\n    if (closed || !fd) {\n      closed = true;\n      if (callback) {\n        callback();\n      }\n    } else {\n      closed = true;\n      fs.close(fd, err => {\n        fd = null;\n        if (callback) {\n          callback(err);\n        }\n      });\n    }\n  };\n  const originalEmit = events.EventEmitter.prototype.emit;\n  this.emit = function () {\n    if (!closed) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return originalEmit.call(this, ...args);\n    }\n  };\n};\nStreamZip.setFs = function (customFs) {\n  fs = customFs;\n};\nStreamZip.debugLog = function () {\n  if (StreamZip.debug) {\n    // eslint-disable-next-line no-console\n    console.log(...arguments);\n  }\n};\nutil.inherits(StreamZip, events.EventEmitter);\nconst propZip = Symbol('zip');\nStreamZip.async = class StreamZipAsync extends events.EventEmitter {\n  constructor(config) {\n    super();\n    const zip = new StreamZip(config);\n    zip.on('entry', entry => this.emit('entry', entry));\n    zip.on('extract', (entry, outPath) => this.emit('extract', entry, outPath));\n    this[propZip] = new Promise((resolve, reject) => {\n      zip.on('ready', () => {\n        zip.removeListener('error', reject);\n        resolve(zip);\n      });\n      zip.on('error', reject);\n    });\n  }\n  get entriesCount() {\n    return this[propZip].then(zip => zip.entriesCount);\n  }\n  get comment() {\n    return this[propZip].then(zip => zip.comment);\n  }\n  async entry(name) {\n    const zip = await this[propZip];\n    return zip.entry(name);\n  }\n  async entries() {\n    const zip = await this[propZip];\n    return zip.entries();\n  }\n  async stream(entry) {\n    const zip = await this[propZip];\n    return new Promise((resolve, reject) => {\n      zip.stream(entry, (err, stm) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(stm);\n        }\n      });\n    });\n  }\n  async entryData(entry) {\n    const stm = await this.stream(entry);\n    return new Promise((resolve, reject) => {\n      const data = [];\n      stm.on('data', chunk => data.push(chunk));\n      stm.on('end', () => {\n        resolve(Buffer.concat(data));\n      });\n      stm.on('error', err => {\n        stm.removeAllListeners('end');\n        reject(err);\n      });\n    });\n  }\n  async extract(entry, outPath) {\n    const zip = await this[propZip];\n    return new Promise((resolve, reject) => {\n      zip.extract(entry, outPath, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n    });\n  }\n  async close() {\n    const zip = await this[propZip];\n    return new Promise((resolve, reject) => {\n      zip.close(err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n};\nclass CentralDirectoryHeader {\n  read(data) {\n    if (data.length !== consts.ENDHDR || data.readUInt32LE(0) !== consts.ENDSIG) {\n      throw new Error('Invalid central directory');\n    }\n    // number of entries on this volume\n    this.volumeEntries = data.readUInt16LE(consts.ENDSUB);\n    // total number of entries\n    this.totalEntries = data.readUInt16LE(consts.ENDTOT);\n    // central directory size in bytes\n    this.size = data.readUInt32LE(consts.ENDSIZ);\n    // offset of first CEN header\n    this.offset = data.readUInt32LE(consts.ENDOFF);\n    // zip file comment length\n    this.commentLength = data.readUInt16LE(consts.ENDCOM);\n  }\n}\nclass CentralDirectoryLoc64Header {\n  read(data) {\n    if (data.length !== consts.ENDL64HDR || data.readUInt32LE(0) !== consts.ENDL64SIG) {\n      throw new Error('Invalid zip64 central directory locator');\n    }\n    // ZIP64 EOCD header offset\n    this.headerOffset = readUInt64LE(data, consts.ENDSUB);\n  }\n}\nclass CentralDirectoryZip64Header {\n  read(data) {\n    if (data.length !== consts.END64HDR || data.readUInt32LE(0) !== consts.END64SIG) {\n      throw new Error('Invalid central directory');\n    }\n    // number of entries on this volume\n    this.volumeEntries = readUInt64LE(data, consts.END64SUB);\n    // total number of entries\n    this.totalEntries = readUInt64LE(data, consts.END64TOT);\n    // central directory size in bytes\n    this.size = readUInt64LE(data, consts.END64SIZ);\n    // offset of first CEN header\n    this.offset = readUInt64LE(data, consts.END64OFF);\n  }\n}\nclass ZipEntry {\n  readHeader(data, offset) {\n    // data should be 46 bytes and start with \"PK 01 02\"\n    if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {\n      throw new Error('Invalid entry header');\n    }\n    // version made by\n    this.verMade = data.readUInt16LE(offset + consts.CENVEM);\n    // version needed to extract\n    this.version = data.readUInt16LE(offset + consts.CENVER);\n    // encrypt, decrypt flags\n    this.flags = data.readUInt16LE(offset + consts.CENFLG);\n    // compression method\n    this.method = data.readUInt16LE(offset + consts.CENHOW);\n    // modification time (2 bytes time, 2 bytes date)\n    const timebytes = data.readUInt16LE(offset + consts.CENTIM);\n    const datebytes = data.readUInt16LE(offset + consts.CENTIM + 2);\n    this.time = parseZipTime(timebytes, datebytes);\n\n    // uncompressed file crc-32 value\n    this.crc = data.readUInt32LE(offset + consts.CENCRC);\n    // compressed size\n    this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);\n    // uncompressed size\n    this.size = data.readUInt32LE(offset + consts.CENLEN);\n    // filename length\n    this.fnameLen = data.readUInt16LE(offset + consts.CENNAM);\n    // extra field length\n    this.extraLen = data.readUInt16LE(offset + consts.CENEXT);\n    // file comment length\n    this.comLen = data.readUInt16LE(offset + consts.CENCOM);\n    // volume number start\n    this.diskStart = data.readUInt16LE(offset + consts.CENDSK);\n    // internal file attributes\n    this.inattr = data.readUInt16LE(offset + consts.CENATT);\n    // external file attributes\n    this.attr = data.readUInt32LE(offset + consts.CENATX);\n    // LOC header offset\n    this.offset = data.readUInt32LE(offset + consts.CENOFF);\n  }\n  readDataHeader(data) {\n    // 30 bytes and should start with \"PK\\003\\004\"\n    if (data.readUInt32LE(0) !== consts.LOCSIG) {\n      throw new Error('Invalid local header');\n    }\n    // version needed to extract\n    this.version = data.readUInt16LE(consts.LOCVER);\n    // general purpose bit flag\n    this.flags = data.readUInt16LE(consts.LOCFLG);\n    // compression method\n    this.method = data.readUInt16LE(consts.LOCHOW);\n    // modification time (2 bytes time ; 2 bytes date)\n    const timebytes = data.readUInt16LE(consts.LOCTIM);\n    const datebytes = data.readUInt16LE(consts.LOCTIM + 2);\n    this.time = parseZipTime(timebytes, datebytes);\n\n    // uncompressed file crc-32 value\n    this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc;\n    // compressed size\n    const compressedSize = data.readUInt32LE(consts.LOCSIZ);\n    if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n      this.compressedSize = compressedSize;\n    }\n    // uncompressed size\n    const size = data.readUInt32LE(consts.LOCLEN);\n    if (size && size !== consts.EF_ZIP64_OR_32) {\n      this.size = size;\n    }\n    // filename length\n    this.fnameLen = data.readUInt16LE(consts.LOCNAM);\n    // extra field length\n    this.extraLen = data.readUInt16LE(consts.LOCEXT);\n  }\n  read(data, offset, textDecoder) {\n    const nameData = data.slice(offset, offset += this.fnameLen);\n    this.name = textDecoder ? textDecoder.decode(new Uint8Array(nameData)) : nameData.toString('utf8');\n    const lastChar = data[offset - 1];\n    this.isDirectory = lastChar === 47 || lastChar === 92;\n    if (this.extraLen) {\n      this.readExtra(data, offset);\n      offset += this.extraLen;\n    }\n    this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n  }\n  validateName() {\n    if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n      throw new Error('Malicious entry: ' + this.name);\n    }\n  }\n  readExtra(data, offset) {\n    let signature, size;\n    const maxPos = offset + this.extraLen;\n    while (offset < maxPos) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n      if (consts.ID_ZIP64 === signature) {\n        this.parseZip64Extra(data, offset, size);\n      }\n      offset += size;\n    }\n  }\n  parseZip64Extra(data, offset, length) {\n    if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n      this.size = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n    if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n      this.compressedSize = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n    if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n      this.offset = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n    if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n      this.diskStart = data.readUInt32LE(offset);\n      // offset += 4; length -= 4;\n    }\n  }\n\n  get encrypted() {\n    return (this.flags & consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;\n  }\n  get isFile() {\n    return !this.isDirectory;\n  }\n}\nclass FsRead {\n  constructor(fd, buffer, offset, length, position, callback) {\n    this.fd = fd;\n    this.buffer = buffer;\n    this.offset = offset;\n    this.length = length;\n    this.position = position;\n    this.callback = callback;\n    this.bytesRead = 0;\n    this.waiting = false;\n  }\n  read(sync) {\n    StreamZip.debugLog('read', this.position, this.bytesRead, this.length, this.offset);\n    this.waiting = true;\n    let err;\n    if (sync) {\n      let bytesRead = 0;\n      try {\n        bytesRead = fs.readSync(this.fd, this.buffer, this.offset + this.bytesRead, this.length - this.bytesRead, this.position + this.bytesRead);\n      } catch (e) {\n        err = e;\n      }\n      this.readCallback(sync, err, err ? bytesRead : null);\n    } else {\n      fs.read(this.fd, this.buffer, this.offset + this.bytesRead, this.length - this.bytesRead, this.position + this.bytesRead, this.readCallback.bind(this, sync));\n    }\n  }\n  readCallback(sync, err, bytesRead) {\n    if (typeof bytesRead === 'number') {\n      this.bytesRead += bytesRead;\n    }\n    if (err || !bytesRead || this.bytesRead === this.length) {\n      this.waiting = false;\n      return this.callback(err, this.bytesRead);\n    } else {\n      this.read(sync);\n    }\n  }\n}\nclass FileWindowBuffer {\n  constructor(fd) {\n    this.position = 0;\n    this.buffer = Buffer.alloc(0);\n    this.fd = fd;\n    this.fsOp = null;\n  }\n  checkOp() {\n    if (this.fsOp && this.fsOp.waiting) {\n      throw new Error('Operation in progress');\n    }\n  }\n  read(pos, length, callback) {\n    this.checkOp();\n    if (this.buffer.length < length) {\n      this.buffer = Buffer.alloc(length);\n    }\n    this.position = pos;\n    this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n  }\n  expandLeft(length, callback) {\n    this.checkOp();\n    this.buffer = Buffer.concat([Buffer.alloc(length), this.buffer]);\n    this.position -= length;\n    if (this.position < 0) {\n      this.position = 0;\n    }\n    this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n  }\n  expandRight(length, callback) {\n    this.checkOp();\n    const offset = this.buffer.length;\n    this.buffer = Buffer.concat([this.buffer, Buffer.alloc(length)]);\n    this.fsOp = new FsRead(this.fd, this.buffer, offset, length, this.position + offset, callback).read();\n  }\n  moveRight(length, callback, shift) {\n    this.checkOp();\n    if (shift) {\n      this.buffer.copy(this.buffer, 0, shift);\n    } else {\n      shift = 0;\n    }\n    this.position += shift;\n    this.fsOp = new FsRead(this.fd, this.buffer, this.buffer.length - shift, shift, this.position + this.buffer.length - shift, callback).read();\n  }\n}\nclass EntryDataReaderStream extends stream.Readable {\n  constructor(fd, offset, length) {\n    super();\n    this.fd = fd;\n    this.offset = offset;\n    this.length = length;\n    this.pos = 0;\n    this.readCallback = this.readCallback.bind(this);\n  }\n  _read(n) {\n    const buffer = Buffer.alloc(Math.min(n, this.length - this.pos));\n    if (buffer.length) {\n      fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n    } else {\n      this.push(null);\n    }\n  }\n  readCallback(err, bytesRead, buffer) {\n    this.pos += bytesRead;\n    if (err) {\n      this.emit('error', err);\n      this.push(null);\n    } else if (!bytesRead) {\n      this.push(null);\n    } else {\n      if (bytesRead !== buffer.length) {\n        buffer = buffer.slice(0, bytesRead);\n      }\n      this.push(buffer);\n    }\n  }\n}\nclass EntryVerifyStream extends stream.Transform {\n  constructor(baseStm, crc, size) {\n    super();\n    this.verify = new CrcVerify(crc, size);\n    baseStm.on('error', e => {\n      this.emit('error', e);\n    });\n  }\n  _transform(data, encoding, callback) {\n    let err;\n    try {\n      this.verify.data(data);\n    } catch (e) {\n      err = e;\n    }\n    callback(err, data);\n  }\n}\nclass CrcVerify {\n  constructor(crc, size) {\n    this.crc = crc;\n    this.size = size;\n    this.state = {\n      crc: ~0,\n      size: 0\n    };\n  }\n  data(data) {\n    const crcTable = CrcVerify.getCrcTable();\n    let crc = this.state.crc;\n    let off = 0;\n    let len = data.length;\n    while (--len >= 0) {\n      crc = crcTable[(crc ^ data[off++]) & 0xff] ^ crc >>> 8;\n    }\n    this.state.crc = crc;\n    this.state.size += data.length;\n    if (this.state.size >= this.size) {\n      const buf = Buffer.alloc(4);\n      buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n      crc = buf.readUInt32LE(0);\n      if (crc !== this.crc) {\n        throw new Error('Invalid CRC');\n      }\n      if (this.state.size !== this.size) {\n        throw new Error('Invalid size');\n      }\n    }\n  }\n  static getCrcTable() {\n    let crcTable = CrcVerify.crcTable;\n    if (!crcTable) {\n      CrcVerify.crcTable = crcTable = [];\n      const b = Buffer.alloc(4);\n      for (let n = 0; n < 256; n++) {\n        let c = n;\n        for (let k = 8; --k >= 0;) {\n          if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ c >>> 1;\n          } else {\n            c = c >>> 1;\n          }\n        }\n        if (c < 0) {\n          b.writeInt32LE(c, 0);\n          c = b.readUInt32LE(0);\n        }\n        crcTable[n] = c;\n      }\n    }\n    return crcTable;\n  }\n}\nfunction parseZipTime(timebytes, datebytes) {\n  const timebits = toBits(timebytes, 16);\n  const datebits = toBits(datebytes, 16);\n  const mt = {\n    h: parseInt(timebits.slice(0, 5).join(''), 2),\n    m: parseInt(timebits.slice(5, 11).join(''), 2),\n    s: parseInt(timebits.slice(11, 16).join(''), 2) * 2,\n    Y: parseInt(datebits.slice(0, 7).join(''), 2) + 1980,\n    M: parseInt(datebits.slice(7, 11).join(''), 2),\n    D: parseInt(datebits.slice(11, 16).join(''), 2)\n  };\n  const dt_str = [mt.Y, mt.M, mt.D].join('-') + ' ' + [mt.h, mt.m, mt.s].join(':') + ' GMT+0';\n  return new Date(dt_str).getTime();\n}\nfunction toBits(dec, size) {\n  let b = (dec >>> 0).toString(2);\n  while (b.length < size) {\n    b = '0' + b;\n  }\n  return b.split('');\n}\nfunction readUInt64LE(buffer, offset) {\n  return buffer.readUInt32LE(offset + 4) * 0x0000000100000000 + buffer.readUInt32LE(offset);\n}\nmodule.exports = StreamZip;","map":{"version":3,"names":["fs","require","util","path","events","zlib","stream","consts","LOCHDR","LOCSIG","LOCVER","LOCFLG","LOCHOW","LOCTIM","LOCCRC","LOCSIZ","LOCLEN","LOCNAM","LOCEXT","EXTSIG","EXTHDR","EXTCRC","EXTSIZ","EXTLEN","CENHDR","CENSIG","CENVEM","CENVER","CENFLG","CENHOW","CENTIM","CENCRC","CENSIZ","CENLEN","CENNAM","CENEXT","CENCOM","CENDSK","CENATT","CENATX","CENOFF","ENDHDR","ENDSIG","ENDSIGFIRST","ENDSUB","ENDTOT","ENDSIZ","ENDOFF","ENDCOM","MAXFILECOMMENT","ENDL64HDR","ENDL64SIG","ENDL64SIGFIRST","ENDL64OFS","END64HDR","END64SIG","END64SIGFIRST","END64SUB","END64TOT","END64SIZ","END64OFF","STORED","SHRUNK","REDUCED1","REDUCED2","REDUCED3","REDUCED4","IMPLODED","DEFLATED","ENHANCED_DEFLATED","PKWARE","BZIP2","LZMA","IBM_TERSE","IBM_LZ77","FLG_ENC","FLG_COMP1","FLG_COMP2","FLG_DESC","FLG_ENH","FLG_STR","FLG_LNG","FLG_MSK","FLG_ENTRY_ENC","EF_ID","EF_SIZE","ID_ZIP64","ID_AVINFO","ID_PFS","ID_OS2","ID_NTFS","ID_OPENVMS","ID_UNIX","ID_FORK","ID_PATCH","ID_X509_PKCS7","ID_X509_CERTID_F","ID_X509_CERTID_C","ID_STRONGENC","ID_RECORD_MGT","ID_X509_PKCS7_RL","ID_IBM1","ID_IBM2","ID_POSZIP","EF_ZIP64_OR_32","EF_ZIP64_OR_16","StreamZip","config","fd","fileSize","chunkSize","op","centralDirectory","closed","ready","that","entries","storeEntries","fileName","file","textDecoder","nameEncoding","TextDecoder","open","readFile","err","f","emit","fstat","stat","size","Math","round","max","min","readCentralDirectory","readUntilFoundCallback","bytesRead","Error","pos","lastPos","bufferPosition","win","position","buffer","minPos","length","firstByte","readUInt32LE","sig","lastBufferPosition","lastBytesRead","complete","expandLength","expandLeft","totalReadLength","FileWindowBuffer","readCentralDirectoryComplete","read","CentralDirectoryHeader","slice","headerOffset","commentLength","comment","toString","entriesCount","volumeEntries","totalEntries","offset","readZip64CentralDirectoryLocator","readEntries","readZip64CentralDirectoryLocatorComplete","locHeader","CentralDirectoryLoc64Header","readLength","readZip64CentralDirectoryComplete","zip64cd","CentralDirectoryZip64Header","entriesLeft","readEntriesCallback","bufferPos","entry","bufferLength","ZipEntry","readHeader","entryHeaderSize","fnameLen","extraLen","comLen","advanceBytes","moveRight","move","skipEntryNameValidation","validateName","name","checkEntriesExist","Object","defineProperty","get","callback","openEntry","dataOffset","entryStream","EntryDataReaderStream","compressedSize","method","pipe","createInflateRaw","canVerifyCrc","EntryVerifyStream","crc","entryDataSync","e","en","data","Buffer","alloc","FsRead","inflateRawSync","verify","CrcVerify","sync","isFile","readEx","readDataHeader","encrypted","ex","flags","extract","outPath","stm","fsStm","errThrown","on","unpipe","close","fdFile","createWriteStream","createDirectories","baseDir","dirs","dir","shift","join","mkdir","recursive","code","extractFiles","baseRelPath","files","extractedCount","targetPath","replace","entryName","isDirectory","allDirs","prototype","hasOwnProperty","call","lastIndexOf","relPath","childEntry","push","dirname","parts","split","filter","partsPath","sort","x","y","basename","originalEmit","EventEmitter","_len","arguments","args","Array","_key","setFs","customFs","debugLog","debug","console","log","inherits","propZip","Symbol","async","StreamZipAsync","constructor","zip","Promise","resolve","reject","removeListener","then","entryData","chunk","concat","removeAllListeners","res","readUInt16LE","readUInt64LE","verMade","version","timebytes","datebytes","time","parseZipTime","diskStart","inattr","attr","nameData","decode","Uint8Array","lastChar","readExtra","test","signature","maxPos","parseZip64Extra","waiting","readSync","readCallback","bind","fsOp","checkOp","expandRight","copy","Readable","_read","n","Transform","baseStm","_transform","encoding","state","crcTable","getCrcTable","off","len","buf","writeInt32LE","b","c","k","timebits","toBits","datebits","mt","h","parseInt","m","s","Y","M","D","dt_str","Date","getTime","dec","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/node-stream-zip/node_stream_zip.js"],"sourcesContent":["/**\n * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE\n */\n\nlet fs = require('fs');\nconst util = require('util');\nconst path = require('path');\nconst events = require('events');\nconst zlib = require('zlib');\nconst stream = require('stream');\n\nconst consts = {\n    /* The local file header */\n    LOCHDR: 30, // LOC header size\n    LOCSIG: 0x04034b50, // \"PK\\003\\004\"\n    LOCVER: 4, // version needed to extract\n    LOCFLG: 6, // general purpose bit flag\n    LOCHOW: 8, // compression method\n    LOCTIM: 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC: 14, // uncompressed file crc-32 value\n    LOCSIZ: 18, // compressed size\n    LOCLEN: 22, // uncompressed size\n    LOCNAM: 26, // filename length\n    LOCEXT: 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG: 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR: 16, // EXT header size\n    EXTCRC: 4, // uncompressed file crc-32 value\n    EXTSIZ: 8, // compressed size\n    EXTLEN: 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR: 46, // CEN header size\n    CENSIG: 0x02014b50, // \"PK\\001\\002\"\n    CENVEM: 4, // version made by\n    CENVER: 6, // version needed to extract\n    CENFLG: 8, // encrypt, decrypt flags\n    CENHOW: 10, // compression method\n    CENTIM: 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC: 16, // uncompressed file crc-32 value\n    CENSIZ: 20, // compressed size\n    CENLEN: 24, // uncompressed size\n    CENNAM: 28, // filename length\n    CENEXT: 30, // extra field length\n    CENCOM: 32, // file comment length\n    CENDSK: 34, // volume number start\n    CENATT: 36, // internal file attributes\n    CENATX: 38, // external file attributes (host system dependent)\n    CENOFF: 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR: 22, // END header size\n    ENDSIG: 0x06054b50, // \"PK\\005\\006\"\n    ENDSIGFIRST: 0x50,\n    ENDSUB: 8, // number of entries on this disk\n    ENDTOT: 10, // total number of entries\n    ENDSIZ: 12, // central directory size in bytes\n    ENDOFF: 16, // offset of first CEN header\n    ENDCOM: 20, // zip file comment length\n    MAXFILECOMMENT: 0xffff,\n\n    /* The entries in the end of ZIP64 central directory locator */\n    ENDL64HDR: 20, // ZIP64 end of central directory locator header size\n    ENDL64SIG: 0x07064b50, // ZIP64 end of central directory locator signature\n    ENDL64SIGFIRST: 0x50,\n    ENDL64OFS: 8, // ZIP64 end of central directory offset\n\n    /* The entries in the end of ZIP64 central directory */\n    END64HDR: 56, // ZIP64 end of central directory header size\n    END64SIG: 0x06064b50, // ZIP64 end of central directory signature\n    END64SIGFIRST: 0x50,\n    END64SUB: 24, // number of entries on this disk\n    END64TOT: 32, // total number of entries\n    END64SIZ: 40,\n    END64OFF: 48,\n\n    /* Compression methods */\n    STORED: 0, // no compression\n    SHRUNK: 1, // shrunk\n    REDUCED1: 2, // reduced with compression factor 1\n    REDUCED2: 3, // reduced with compression factor 2\n    REDUCED3: 4, // reduced with compression factor 3\n    REDUCED4: 5, // reduced with compression factor 4\n    IMPLODED: 6, // imploded\n    // 7 reserved\n    DEFLATED: 8, // deflated\n    ENHANCED_DEFLATED: 9, // deflate64\n    PKWARE: 10, // PKWare DCL imploded\n    // 11 reserved\n    BZIP2: 12, //  compressed using BZIP2\n    // 13 reserved\n    LZMA: 14, // LZMA\n    // 15-17 reserved\n    IBM_TERSE: 18, // compressed using IBM TERSE\n    IBM_LZ77: 19, //IBM LZ77 z\n\n    /* General purpose bit flag */\n    FLG_ENC: 0, // encrypted file\n    FLG_COMP1: 1, // compression option\n    FLG_COMP2: 2, // compression option\n    FLG_DESC: 4, // data descriptor\n    FLG_ENH: 8, // enhanced deflation\n    FLG_STR: 16, // strong encryption\n    FLG_LNG: 1024, // language encoding\n    FLG_MSK: 4096, // mask header values\n    FLG_ENTRY_ENC: 1,\n\n    /* 4.5 Extensible data fields */\n    EF_ID: 0,\n    EF_SIZE: 2,\n\n    /* Header IDs */\n    ID_ZIP64: 0x0001,\n    ID_AVINFO: 0x0007,\n    ID_PFS: 0x0008,\n    ID_OS2: 0x0009,\n    ID_NTFS: 0x000a,\n    ID_OPENVMS: 0x000c,\n    ID_UNIX: 0x000d,\n    ID_FORK: 0x000e,\n    ID_PATCH: 0x000f,\n    ID_X509_PKCS7: 0x0014,\n    ID_X509_CERTID_F: 0x0015,\n    ID_X509_CERTID_C: 0x0016,\n    ID_STRONGENC: 0x0017,\n    ID_RECORD_MGT: 0x0018,\n    ID_X509_PKCS7_RL: 0x0019,\n    ID_IBM1: 0x0065,\n    ID_IBM2: 0x0066,\n    ID_POSZIP: 0x4690,\n\n    EF_ZIP64_OR_32: 0xffffffff,\n    EF_ZIP64_OR_16: 0xffff,\n};\n\nconst StreamZip = function (config) {\n    let fd, fileSize, chunkSize, op, centralDirectory, closed;\n    const ready = false,\n        that = this,\n        entries = config.storeEntries !== false ? {} : null,\n        fileName = config.file,\n        textDecoder = config.nameEncoding ? new TextDecoder(config.nameEncoding) : null;\n\n    open();\n\n    function open() {\n        if (config.fd) {\n            fd = config.fd;\n            readFile();\n        } else {\n            fs.open(fileName, 'r', (err, f) => {\n                if (err) {\n                    return that.emit('error', err);\n                }\n                fd = f;\n                readFile();\n            });\n        }\n    }\n\n    function readFile() {\n        fs.fstat(fd, (err, stat) => {\n            if (err) {\n                return that.emit('error', err);\n            }\n            fileSize = stat.size;\n            chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n            chunkSize = Math.max(\n                Math.min(chunkSize, Math.min(128 * 1024, fileSize)),\n                Math.min(1024, fileSize)\n            );\n            readCentralDirectory();\n        });\n    }\n\n    function readUntilFoundCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Archive read error'));\n        }\n        let pos = op.lastPos;\n        let bufferPosition = pos - op.win.position;\n        const buffer = op.win.buffer;\n        const minPos = op.minPos;\n        while (--pos >= minPos && --bufferPosition >= 0) {\n            if (buffer.length - bufferPosition >= 4 && buffer[bufferPosition] === op.firstByte) {\n                // quick check first signature byte\n                if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n                    op.lastBufferPosition = bufferPosition;\n                    op.lastBytesRead = bytesRead;\n                    op.complete();\n                    return;\n                }\n            }\n        }\n        if (pos === minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        op.lastPos = pos + 1;\n        op.chunkSize *= 2;\n        if (pos <= minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        const expandLength = Math.min(op.chunkSize, pos - minPos);\n        op.win.expandLeft(expandLength, readUntilFoundCallback);\n    }\n\n    function readCentralDirectory() {\n        const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n        op = {\n            win: new FileWindowBuffer(fd),\n            totalReadLength,\n            minPos: fileSize - totalReadLength,\n            lastPos: fileSize,\n            chunkSize: Math.min(1024, chunkSize),\n            firstByte: consts.ENDSIGFIRST,\n            sig: consts.ENDSIG,\n            complete: readCentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readCentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const pos = op.lastBufferPosition;\n        try {\n            centralDirectory = new CentralDirectoryHeader();\n            centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n            centralDirectory.headerOffset = op.win.position + pos;\n            if (centralDirectory.commentLength) {\n                that.comment = buffer\n                    .slice(\n                        pos + consts.ENDHDR,\n                        pos + consts.ENDHDR + centralDirectory.commentLength\n                    )\n                    .toString();\n            } else {\n                that.comment = null;\n            }\n            that.entriesCount = centralDirectory.volumeEntries;\n            that.centralDirectory = centralDirectory;\n            if (\n                (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 &&\n                    centralDirectory.totalEntries === consts.EF_ZIP64_OR_16) ||\n                centralDirectory.size === consts.EF_ZIP64_OR_32 ||\n                centralDirectory.offset === consts.EF_ZIP64_OR_32\n            ) {\n                readZip64CentralDirectoryLocator();\n            } else {\n                op = {};\n                readEntries();\n            }\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function readZip64CentralDirectoryLocator() {\n        const length = consts.ENDL64HDR;\n        if (op.lastBufferPosition > length) {\n            op.lastBufferPosition -= length;\n            readZip64CentralDirectoryLocatorComplete();\n        } else {\n            op = {\n                win: op.win,\n                totalReadLength: length,\n                minPos: op.win.position - length,\n                lastPos: op.win.position,\n                chunkSize: op.chunkSize,\n                firstByte: consts.ENDL64SIGFIRST,\n                sig: consts.ENDL64SIG,\n                complete: readZip64CentralDirectoryLocatorComplete,\n            };\n            op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n        }\n    }\n\n    function readZip64CentralDirectoryLocatorComplete() {\n        const buffer = op.win.buffer;\n        const locHeader = new CentralDirectoryLoc64Header();\n        locHeader.read(\n            buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR)\n        );\n        const readLength = fileSize - locHeader.headerOffset;\n        op = {\n            win: op.win,\n            totalReadLength: readLength,\n            minPos: locHeader.headerOffset,\n            lastPos: op.lastPos,\n            chunkSize: op.chunkSize,\n            firstByte: consts.END64SIGFIRST,\n            sig: consts.END64SIG,\n            complete: readZip64CentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readZip64CentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const zip64cd = new CentralDirectoryZip64Header();\n        zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n        that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n        that.centralDirectory.totalEntries = zip64cd.totalEntries;\n        that.centralDirectory.size = zip64cd.size;\n        that.centralDirectory.offset = zip64cd.offset;\n        that.entriesCount = zip64cd.volumeEntries;\n        op = {};\n        readEntries();\n    }\n\n    function readEntries() {\n        op = {\n            win: new FileWindowBuffer(fd),\n            pos: centralDirectory.offset,\n            chunkSize,\n            entriesLeft: centralDirectory.volumeEntries,\n        };\n        op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n    }\n\n    function readEntriesCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Entries read error'));\n        }\n        let bufferPos = op.pos - op.win.position;\n        let entry = op.entry;\n        const buffer = op.win.buffer;\n        const bufferLength = buffer.length;\n        try {\n            while (op.entriesLeft > 0) {\n                if (!entry) {\n                    entry = new ZipEntry();\n                    entry.readHeader(buffer, bufferPos);\n                    entry.headerOffset = op.win.position + bufferPos;\n                    op.entry = entry;\n                    op.pos += consts.CENHDR;\n                    bufferPos += consts.CENHDR;\n                }\n                const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n                const advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n                if (bufferLength - bufferPos < advanceBytes) {\n                    op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n                    op.move = true;\n                    return;\n                }\n                entry.read(buffer, bufferPos, textDecoder);\n                if (!config.skipEntryNameValidation) {\n                    entry.validateName();\n                }\n                if (entries) {\n                    entries[entry.name] = entry;\n                }\n                that.emit('entry', entry);\n                op.entry = entry = null;\n                op.entriesLeft--;\n                op.pos += entryHeaderSize;\n                bufferPos += entryHeaderSize;\n            }\n            that.emit('ready');\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function checkEntriesExist() {\n        if (!entries) {\n            throw new Error('storeEntries disabled');\n        }\n    }\n\n    Object.defineProperty(this, 'ready', {\n        get() {\n            return ready;\n        },\n    });\n\n    this.entry = function (name) {\n        checkEntriesExist();\n        return entries[name];\n    };\n\n    this.entries = function () {\n        checkEntriesExist();\n        return entries;\n    };\n\n    this.stream = function (entry, callback) {\n        return this.openEntry(\n            entry,\n            (err, entry) => {\n                if (err) {\n                    return callback(err);\n                }\n                const offset = dataOffset(entry);\n                let entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n                if (entry.method === consts.STORED) {\n                    // nothing to do\n                } else if (entry.method === consts.DEFLATED) {\n                    entryStream = entryStream.pipe(zlib.createInflateRaw());\n                } else {\n                    return callback(new Error('Unknown compression method: ' + entry.method));\n                }\n                if (canVerifyCrc(entry)) {\n                    entryStream = entryStream.pipe(\n                        new EntryVerifyStream(entryStream, entry.crc, entry.size)\n                    );\n                }\n                callback(null, entryStream);\n            },\n            false\n        );\n    };\n\n    this.entryDataSync = function (entry) {\n        let err = null;\n        this.openEntry(\n            entry,\n            (e, en) => {\n                err = e;\n                entry = en;\n            },\n            true\n        );\n        if (err) {\n            throw err;\n        }\n        let data = Buffer.alloc(entry.compressedSize);\n        new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), (e) => {\n            err = e;\n        }).read(true);\n        if (err) {\n            throw err;\n        }\n        if (entry.method === consts.STORED) {\n            // nothing to do\n        } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n            data = zlib.inflateRawSync(data);\n        } else {\n            throw new Error('Unknown compression method: ' + entry.method);\n        }\n        if (data.length !== entry.size) {\n            throw new Error('Invalid size');\n        }\n        if (canVerifyCrc(entry)) {\n            const verify = new CrcVerify(entry.crc, entry.size);\n            verify.data(data);\n        }\n        return data;\n    };\n\n    this.openEntry = function (entry, callback, sync) {\n        if (typeof entry === 'string') {\n            checkEntriesExist();\n            entry = entries[entry];\n            if (!entry) {\n                return callback(new Error('Entry not found'));\n            }\n        }\n        if (!entry.isFile) {\n            return callback(new Error('Entry is not file'));\n        }\n        if (!fd) {\n            return callback(new Error('Archive closed'));\n        }\n        const buffer = Buffer.alloc(consts.LOCHDR);\n        new FsRead(fd, buffer, 0, buffer.length, entry.offset, (err) => {\n            if (err) {\n                return callback(err);\n            }\n            let readEx;\n            try {\n                entry.readDataHeader(buffer);\n                if (entry.encrypted) {\n                    readEx = new Error('Entry encrypted');\n                }\n            } catch (ex) {\n                readEx = ex;\n            }\n            callback(readEx, entry);\n        }).read(sync);\n    };\n\n    function dataOffset(entry) {\n        return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n    }\n\n    function canVerifyCrc(entry) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        return (entry.flags & 0x8) !== 0x8;\n    }\n\n    function extract(entry, outPath, callback) {\n        that.stream(entry, (err, stm) => {\n            if (err) {\n                callback(err);\n            } else {\n                let fsStm, errThrown;\n                stm.on('error', (err) => {\n                    errThrown = err;\n                    if (fsStm) {\n                        stm.unpipe(fsStm);\n                        fsStm.close(() => {\n                            callback(err);\n                        });\n                    }\n                });\n                fs.open(outPath, 'w', (err, fdFile) => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    if (errThrown) {\n                        fs.close(fd, () => {\n                            callback(errThrown);\n                        });\n                        return;\n                    }\n                    fsStm = fs.createWriteStream(outPath, { fd: fdFile });\n                    fsStm.on('finish', () => {\n                        that.emit('extract', entry, outPath);\n                        if (!errThrown) {\n                            callback();\n                        }\n                    });\n                    stm.pipe(fsStm);\n                });\n            }\n        });\n    }\n\n    function createDirectories(baseDir, dirs, callback) {\n        if (!dirs.length) {\n            return callback();\n        }\n        let dir = dirs.shift();\n        dir = path.join(baseDir, path.join(...dir));\n        fs.mkdir(dir, { recursive: true }, (err) => {\n            if (err && err.code !== 'EEXIST') {\n                return callback(err);\n            }\n            createDirectories(baseDir, dirs, callback);\n        });\n    }\n\n    function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n        if (!files.length) {\n            return callback(null, extractedCount);\n        }\n        const file = files.shift();\n        const targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n        extract(file, targetPath, (err) => {\n            if (err) {\n                return callback(err, extractedCount);\n            }\n            extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n        });\n    }\n\n    this.extract = function (entry, outPath, callback) {\n        let entryName = entry || '';\n        if (typeof entry === 'string') {\n            entry = this.entry(entry);\n            if (entry) {\n                entryName = entry.name;\n            } else {\n                if (entryName.length && entryName[entryName.length - 1] !== '/') {\n                    entryName += '/';\n                }\n            }\n        }\n        if (!entry || entry.isDirectory) {\n            const files = [],\n                dirs = [],\n                allDirs = {};\n            for (const e in entries) {\n                if (\n                    Object.prototype.hasOwnProperty.call(entries, e) &&\n                    e.lastIndexOf(entryName, 0) === 0\n                ) {\n                    let relPath = e.replace(entryName, '');\n                    const childEntry = entries[e];\n                    if (childEntry.isFile) {\n                        files.push(childEntry);\n                        relPath = path.dirname(relPath);\n                    }\n                    if (relPath && !allDirs[relPath] && relPath !== '.') {\n                        allDirs[relPath] = true;\n                        let parts = relPath.split('/').filter((f) => {\n                            return f;\n                        });\n                        if (parts.length) {\n                            dirs.push(parts);\n                        }\n                        while (parts.length > 1) {\n                            parts = parts.slice(0, parts.length - 1);\n                            const partsPath = parts.join('/');\n                            if (allDirs[partsPath] || partsPath === '.') {\n                                break;\n                            }\n                            allDirs[partsPath] = true;\n                            dirs.push(parts);\n                        }\n                    }\n                }\n            }\n            dirs.sort((x, y) => {\n                return x.length - y.length;\n            });\n            if (dirs.length) {\n                createDirectories(outPath, dirs, (err) => {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        extractFiles(outPath, entryName, files, callback, 0);\n                    }\n                });\n            } else {\n                extractFiles(outPath, entryName, files, callback, 0);\n            }\n        } else {\n            fs.stat(outPath, (err, stat) => {\n                if (stat && stat.isDirectory()) {\n                    extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n                } else {\n                    extract(entry, outPath, callback);\n                }\n            });\n        }\n    };\n\n    this.close = function (callback) {\n        if (closed || !fd) {\n            closed = true;\n            if (callback) {\n                callback();\n            }\n        } else {\n            closed = true;\n            fs.close(fd, (err) => {\n                fd = null;\n                if (callback) {\n                    callback(err);\n                }\n            });\n        }\n    };\n\n    const originalEmit = events.EventEmitter.prototype.emit;\n    this.emit = function (...args) {\n        if (!closed) {\n            return originalEmit.call(this, ...args);\n        }\n    };\n};\n\nStreamZip.setFs = function (customFs) {\n    fs = customFs;\n};\n\nStreamZip.debugLog = (...args) => {\n    if (StreamZip.debug) {\n        // eslint-disable-next-line no-console\n        console.log(...args);\n    }\n};\n\nutil.inherits(StreamZip, events.EventEmitter);\n\nconst propZip = Symbol('zip');\n\nStreamZip.async = class StreamZipAsync extends events.EventEmitter {\n    constructor(config) {\n        super();\n\n        const zip = new StreamZip(config);\n\n        zip.on('entry', (entry) => this.emit('entry', entry));\n        zip.on('extract', (entry, outPath) => this.emit('extract', entry, outPath));\n\n        this[propZip] = new Promise((resolve, reject) => {\n            zip.on('ready', () => {\n                zip.removeListener('error', reject);\n                resolve(zip);\n            });\n            zip.on('error', reject);\n        });\n    }\n\n    get entriesCount() {\n        return this[propZip].then((zip) => zip.entriesCount);\n    }\n\n    get comment() {\n        return this[propZip].then((zip) => zip.comment);\n    }\n\n    async entry(name) {\n        const zip = await this[propZip];\n        return zip.entry(name);\n    }\n\n    async entries() {\n        const zip = await this[propZip];\n        return zip.entries();\n    }\n\n    async stream(entry) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.stream(entry, (err, stm) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(stm);\n                }\n            });\n        });\n    }\n\n    async entryData(entry) {\n        const stm = await this.stream(entry);\n        return new Promise((resolve, reject) => {\n            const data = [];\n            stm.on('data', (chunk) => data.push(chunk));\n            stm.on('end', () => {\n                resolve(Buffer.concat(data));\n            });\n            stm.on('error', (err) => {\n                stm.removeAllListeners('end');\n                reject(err);\n            });\n        });\n    }\n\n    async extract(entry, outPath) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.extract(entry, outPath, (err, res) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n\n    async close() {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.close((err) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n};\n\nclass CentralDirectoryHeader {\n    read(data) {\n        if (data.length !== consts.ENDHDR || data.readUInt32LE(0) !== consts.ENDSIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = data.readUInt16LE(consts.ENDSUB);\n        // total number of entries\n        this.totalEntries = data.readUInt16LE(consts.ENDTOT);\n        // central directory size in bytes\n        this.size = data.readUInt32LE(consts.ENDSIZ);\n        // offset of first CEN header\n        this.offset = data.readUInt32LE(consts.ENDOFF);\n        // zip file comment length\n        this.commentLength = data.readUInt16LE(consts.ENDCOM);\n    }\n}\n\nclass CentralDirectoryLoc64Header {\n    read(data) {\n        if (data.length !== consts.ENDL64HDR || data.readUInt32LE(0) !== consts.ENDL64SIG) {\n            throw new Error('Invalid zip64 central directory locator');\n        }\n        // ZIP64 EOCD header offset\n        this.headerOffset = readUInt64LE(data, consts.ENDSUB);\n    }\n}\n\nclass CentralDirectoryZip64Header {\n    read(data) {\n        if (data.length !== consts.END64HDR || data.readUInt32LE(0) !== consts.END64SIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = readUInt64LE(data, consts.END64SUB);\n        // total number of entries\n        this.totalEntries = readUInt64LE(data, consts.END64TOT);\n        // central directory size in bytes\n        this.size = readUInt64LE(data, consts.END64SIZ);\n        // offset of first CEN header\n        this.offset = readUInt64LE(data, consts.END64OFF);\n    }\n}\n\nclass ZipEntry {\n    readHeader(data, offset) {\n        // data should be 46 bytes and start with \"PK 01 02\"\n        if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {\n            throw new Error('Invalid entry header');\n        }\n        // version made by\n        this.verMade = data.readUInt16LE(offset + consts.CENVEM);\n        // version needed to extract\n        this.version = data.readUInt16LE(offset + consts.CENVER);\n        // encrypt, decrypt flags\n        this.flags = data.readUInt16LE(offset + consts.CENFLG);\n        // compression method\n        this.method = data.readUInt16LE(offset + consts.CENHOW);\n        // modification time (2 bytes time, 2 bytes date)\n        const timebytes = data.readUInt16LE(offset + consts.CENTIM);\n        const datebytes = data.readUInt16LE(offset + consts.CENTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(offset + consts.CENCRC);\n        // compressed size\n        this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);\n        // uncompressed size\n        this.size = data.readUInt32LE(offset + consts.CENLEN);\n        // filename length\n        this.fnameLen = data.readUInt16LE(offset + consts.CENNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(offset + consts.CENEXT);\n        // file comment length\n        this.comLen = data.readUInt16LE(offset + consts.CENCOM);\n        // volume number start\n        this.diskStart = data.readUInt16LE(offset + consts.CENDSK);\n        // internal file attributes\n        this.inattr = data.readUInt16LE(offset + consts.CENATT);\n        // external file attributes\n        this.attr = data.readUInt32LE(offset + consts.CENATX);\n        // LOC header offset\n        this.offset = data.readUInt32LE(offset + consts.CENOFF);\n    }\n\n    readDataHeader(data) {\n        // 30 bytes and should start with \"PK\\003\\004\"\n        if (data.readUInt32LE(0) !== consts.LOCSIG) {\n            throw new Error('Invalid local header');\n        }\n        // version needed to extract\n        this.version = data.readUInt16LE(consts.LOCVER);\n        // general purpose bit flag\n        this.flags = data.readUInt16LE(consts.LOCFLG);\n        // compression method\n        this.method = data.readUInt16LE(consts.LOCHOW);\n        // modification time (2 bytes time ; 2 bytes date)\n        const timebytes = data.readUInt16LE(consts.LOCTIM);\n        const datebytes = data.readUInt16LE(consts.LOCTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc;\n        // compressed size\n        const compressedSize = data.readUInt32LE(consts.LOCSIZ);\n        if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n            this.compressedSize = compressedSize;\n        }\n        // uncompressed size\n        const size = data.readUInt32LE(consts.LOCLEN);\n        if (size && size !== consts.EF_ZIP64_OR_32) {\n            this.size = size;\n        }\n        // filename length\n        this.fnameLen = data.readUInt16LE(consts.LOCNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(consts.LOCEXT);\n    }\n\n    read(data, offset, textDecoder) {\n        const nameData = data.slice(offset, (offset += this.fnameLen));\n        this.name = textDecoder\n            ? textDecoder.decode(new Uint8Array(nameData))\n            : nameData.toString('utf8');\n        const lastChar = data[offset - 1];\n        this.isDirectory = lastChar === 47 || lastChar === 92;\n\n        if (this.extraLen) {\n            this.readExtra(data, offset);\n            offset += this.extraLen;\n        }\n        this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n    }\n\n    validateName() {\n        if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n            throw new Error('Malicious entry: ' + this.name);\n        }\n    }\n\n    readExtra(data, offset) {\n        let signature, size;\n        const maxPos = offset + this.extraLen;\n        while (offset < maxPos) {\n            signature = data.readUInt16LE(offset);\n            offset += 2;\n            size = data.readUInt16LE(offset);\n            offset += 2;\n            if (consts.ID_ZIP64 === signature) {\n                this.parseZip64Extra(data, offset, size);\n            }\n            offset += size;\n        }\n    }\n\n    parseZip64Extra(data, offset, length) {\n        if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n            this.size = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n            this.compressedSize = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n            this.offset = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n            this.diskStart = data.readUInt32LE(offset);\n            // offset += 4; length -= 4;\n        }\n    }\n\n    get encrypted() {\n        return (this.flags & consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;\n    }\n\n    get isFile() {\n        return !this.isDirectory;\n    }\n}\n\nclass FsRead {\n    constructor(fd, buffer, offset, length, position, callback) {\n        this.fd = fd;\n        this.buffer = buffer;\n        this.offset = offset;\n        this.length = length;\n        this.position = position;\n        this.callback = callback;\n        this.bytesRead = 0;\n        this.waiting = false;\n    }\n\n    read(sync) {\n        StreamZip.debugLog('read', this.position, this.bytesRead, this.length, this.offset);\n        this.waiting = true;\n        let err;\n        if (sync) {\n            let bytesRead = 0;\n            try {\n                bytesRead = fs.readSync(\n                    this.fd,\n                    this.buffer,\n                    this.offset + this.bytesRead,\n                    this.length - this.bytesRead,\n                    this.position + this.bytesRead\n                );\n            } catch (e) {\n                err = e;\n            }\n            this.readCallback(sync, err, err ? bytesRead : null);\n        } else {\n            fs.read(\n                this.fd,\n                this.buffer,\n                this.offset + this.bytesRead,\n                this.length - this.bytesRead,\n                this.position + this.bytesRead,\n                this.readCallback.bind(this, sync)\n            );\n        }\n    }\n\n    readCallback(sync, err, bytesRead) {\n        if (typeof bytesRead === 'number') {\n            this.bytesRead += bytesRead;\n        }\n        if (err || !bytesRead || this.bytesRead === this.length) {\n            this.waiting = false;\n            return this.callback(err, this.bytesRead);\n        } else {\n            this.read(sync);\n        }\n    }\n}\n\nclass FileWindowBuffer {\n    constructor(fd) {\n        this.position = 0;\n        this.buffer = Buffer.alloc(0);\n        this.fd = fd;\n        this.fsOp = null;\n    }\n\n    checkOp() {\n        if (this.fsOp && this.fsOp.waiting) {\n            throw new Error('Operation in progress');\n        }\n    }\n\n    read(pos, length, callback) {\n        this.checkOp();\n        if (this.buffer.length < length) {\n            this.buffer = Buffer.alloc(length);\n        }\n        this.position = pos;\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandLeft(length, callback) {\n        this.checkOp();\n        this.buffer = Buffer.concat([Buffer.alloc(length), this.buffer]);\n        this.position -= length;\n        if (this.position < 0) {\n            this.position = 0;\n        }\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandRight(length, callback) {\n        this.checkOp();\n        const offset = this.buffer.length;\n        this.buffer = Buffer.concat([this.buffer, Buffer.alloc(length)]);\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            offset,\n            length,\n            this.position + offset,\n            callback\n        ).read();\n    }\n\n    moveRight(length, callback, shift) {\n        this.checkOp();\n        if (shift) {\n            this.buffer.copy(this.buffer, 0, shift);\n        } else {\n            shift = 0;\n        }\n        this.position += shift;\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            this.buffer.length - shift,\n            shift,\n            this.position + this.buffer.length - shift,\n            callback\n        ).read();\n    }\n}\n\nclass EntryDataReaderStream extends stream.Readable {\n    constructor(fd, offset, length) {\n        super();\n        this.fd = fd;\n        this.offset = offset;\n        this.length = length;\n        this.pos = 0;\n        this.readCallback = this.readCallback.bind(this);\n    }\n\n    _read(n) {\n        const buffer = Buffer.alloc(Math.min(n, this.length - this.pos));\n        if (buffer.length) {\n            fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n        } else {\n            this.push(null);\n        }\n    }\n\n    readCallback(err, bytesRead, buffer) {\n        this.pos += bytesRead;\n        if (err) {\n            this.emit('error', err);\n            this.push(null);\n        } else if (!bytesRead) {\n            this.push(null);\n        } else {\n            if (bytesRead !== buffer.length) {\n                buffer = buffer.slice(0, bytesRead);\n            }\n            this.push(buffer);\n        }\n    }\n}\n\nclass EntryVerifyStream extends stream.Transform {\n    constructor(baseStm, crc, size) {\n        super();\n        this.verify = new CrcVerify(crc, size);\n        baseStm.on('error', (e) => {\n            this.emit('error', e);\n        });\n    }\n\n    _transform(data, encoding, callback) {\n        let err;\n        try {\n            this.verify.data(data);\n        } catch (e) {\n            err = e;\n        }\n        callback(err, data);\n    }\n}\n\nclass CrcVerify {\n    constructor(crc, size) {\n        this.crc = crc;\n        this.size = size;\n        this.state = {\n            crc: ~0,\n            size: 0,\n        };\n    }\n\n    data(data) {\n        const crcTable = CrcVerify.getCrcTable();\n        let crc = this.state.crc;\n        let off = 0;\n        let len = data.length;\n        while (--len >= 0) {\n            crc = crcTable[(crc ^ data[off++]) & 0xff] ^ (crc >>> 8);\n        }\n        this.state.crc = crc;\n        this.state.size += data.length;\n        if (this.state.size >= this.size) {\n            const buf = Buffer.alloc(4);\n            buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n            crc = buf.readUInt32LE(0);\n            if (crc !== this.crc) {\n                throw new Error('Invalid CRC');\n            }\n            if (this.state.size !== this.size) {\n                throw new Error('Invalid size');\n            }\n        }\n    }\n\n    static getCrcTable() {\n        let crcTable = CrcVerify.crcTable;\n        if (!crcTable) {\n            CrcVerify.crcTable = crcTable = [];\n            const b = Buffer.alloc(4);\n            for (let n = 0; n < 256; n++) {\n                let c = n;\n                for (let k = 8; --k >= 0; ) {\n                    if ((c & 1) !== 0) {\n                        c = 0xedb88320 ^ (c >>> 1);\n                    } else {\n                        c = c >>> 1;\n                    }\n                }\n                if (c < 0) {\n                    b.writeInt32LE(c, 0);\n                    c = b.readUInt32LE(0);\n                }\n                crcTable[n] = c;\n            }\n        }\n        return crcTable;\n    }\n}\n\nfunction parseZipTime(timebytes, datebytes) {\n    const timebits = toBits(timebytes, 16);\n    const datebits = toBits(datebytes, 16);\n\n    const mt = {\n        h: parseInt(timebits.slice(0, 5).join(''), 2),\n        m: parseInt(timebits.slice(5, 11).join(''), 2),\n        s: parseInt(timebits.slice(11, 16).join(''), 2) * 2,\n        Y: parseInt(datebits.slice(0, 7).join(''), 2) + 1980,\n        M: parseInt(datebits.slice(7, 11).join(''), 2),\n        D: parseInt(datebits.slice(11, 16).join(''), 2),\n    };\n    const dt_str = [mt.Y, mt.M, mt.D].join('-') + ' ' + [mt.h, mt.m, mt.s].join(':') + ' GMT+0';\n    return new Date(dt_str).getTime();\n}\n\nfunction toBits(dec, size) {\n    let b = (dec >>> 0).toString(2);\n    while (b.length < size) {\n        b = '0' + b;\n    }\n    return b.split('');\n}\n\nfunction readUInt64LE(buffer, offset) {\n    return buffer.readUInt32LE(offset + 4) * 0x0000000100000000 + buffer.readUInt32LE(offset);\n}\n\nmodule.exports = StreamZip;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}