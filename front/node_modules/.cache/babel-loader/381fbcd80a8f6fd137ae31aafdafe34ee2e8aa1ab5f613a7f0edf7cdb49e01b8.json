{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar Stream = require('stream').Stream;\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n  var stream = new Stream(),\n    inputs = 0,\n    outputs = 0,\n    ended = false,\n    paused = false,\n    destroyed = false,\n    lastWritten = 0,\n    inNext = false;\n  opts = opts || {};\n  var errorEventName = opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {};\n  stream.writable = true;\n  stream.readable = true;\n  function queueData(data, number) {\n    var nextToWrite = lastWritten + 1;\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data]);\n      }\n      lastWritten++;\n      nextToWrite++;\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data;\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite];\n      delete writeQueue[nextToWrite];\n      return queueData(dataToWrite, nextToWrite);\n    }\n    outputs++;\n    if (inputs === outputs) {\n      if (paused) paused = false, stream.emit('drain'); //written all the incoming events\n      if (ended) end();\n    }\n  }\n  function next(err, data, number) {\n    if (destroyed) return;\n    inNext = true;\n    if (!err || opts.failures) {\n      queueData(data, number);\n    }\n    if (err) {\n      stream.emit.apply(stream, [errorEventName, err]);\n    }\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper(input, number, callback) {\n    return mapper.call(null, input, function (err, data) {\n      callback(err, data, number);\n    });\n  }\n  stream.write = function (data) {\n    if (ended) throw new Error('map stream is not writable');\n    inNext = false;\n    inputs++;\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next);\n      paused = written === false;\n      return !paused;\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if (inNext) throw err;\n      next(err);\n      return !paused;\n    }\n  };\n  function end(data) {\n    //if end was called with args, write it, \n    ended = true; //write will emit 'end' if ended is true\n    stream.writable = false;\n    if (data !== undefined) {\n      return queueData(data, inputs);\n    } else if (inputs == outputs) {\n      //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy();\n    }\n  }\n  stream.end = function (data) {\n    if (ended) return;\n    end(data);\n  };\n  stream.destroy = function () {\n    ended = destroyed = true;\n    stream.writable = stream.readable = paused = false;\n    process.nextTick(function () {\n      stream.emit('close');\n    });\n  };\n  stream.pause = function () {\n    paused = true;\n  };\n  stream.resume = function () {\n    paused = false;\n  };\n  return stream;\n};","map":{"version":3,"names":["Stream","require","module","exports","mapper","opts","stream","inputs","outputs","ended","paused","destroyed","lastWritten","inNext","errorEventName","failures","writeQueue","writable","readable","queueData","data","number","nextToWrite","undefined","emit","apply","hasOwnProperty","dataToWrite","end","next","err","wrappedMapper","input","callback","call","write","Error","written","destroy","process","nextTick","pause","resume"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/map-stream/index.js"],"sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  opts = opts || {};\n  var errorEventName = opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end(data)\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}