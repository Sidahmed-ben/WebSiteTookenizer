{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Class for a Slot Manager that takes care of the slot information.\n */\nclass SlotManager {\n  /**\n   * Constructor of the class.\n   */\n  constructor() {\n    this.intents = {};\n    this.isEmpty = true;\n  }\n\n  /**\n   * Returns an slot given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {Object} Slot or undefined if not found.\n   */\n  getSlot(intent, entity) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Indicates if a given slot exists, given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {boolean} True if the slot exists, false otherwise.\n   */\n  existsSlot(intent, entity) {\n    return this.getSlot(intent, entity) !== undefined;\n  }\n\n  /**\n   * Adds a new slot for a given intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} [mandatory=false] Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New slot instance.\n   */\n  addSlot(intent, entity) {\n    let mandatory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let questions = arguments.length > 3 ? arguments[3] : undefined;\n    this.isEmpty = false;\n    if (!this.intents[intent]) {\n      this.intents[intent] = {};\n    }\n    this.intents[intent][entity] = {\n      intent,\n      entity,\n      mandatory,\n      locales: questions || {}\n    };\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Adds/modifies the parameter of a slot for a given intent and entity.\n   * Slot questions for same locales as already existing will be overwritten.\n   * If the slot for the intent and entity does not exist it fill be created.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} mandatory Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New/Modified slot instance or undefined if not existing\n   */\n  updateSlot(intent, entity, mandatory, questions) {\n    if (!this.intents[intent] || !this.intents[intent][entity]) {\n      return this.addSlot(intent, entity, mandatory, questions);\n    }\n    const slot = this.intents[intent][entity];\n    if (mandatory !== undefined) {\n      // Update mandatory flag only if provided\n      slot.mandatory = mandatory;\n    }\n    slot.locales = Object.assign(slot.locales, questions);\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Remove an slot given the intent and the entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   */\n  removeSlot(intent, entity) {\n    if (this.intents[intent]) {\n      delete this.intents[intent][entity];\n    }\n  }\n\n  /**\n   * Add several entities if they don't exists.\n   * @param {String} intent Name of the intent.\n   * @param {String[]} entities List of entities.\n   * @returns {Object[]} Array of resulting entities.\n   */\n  addBatch(intent, entities) {\n    const result = [];\n    if (entities && entities.length > 0) {\n      entities.forEach(entity => {\n        let slot = this.getSlot(intent, entity);\n        if (!slot) {\n          slot = this.addSlot(intent, entity);\n        }\n        result.push(slot);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Given an intent, return the array of entity names of this intent.\n   * @param {String} intent Name of the intent.\n   * @returns {String[]} Array of entity names of the intent.\n   */\n  getIntentEntityNames(intent) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return Object.keys(this.intents[intent]);\n  }\n\n  /**\n   * Given an intent return the information if the intent has entities defined\n   *\n   * @param {String} intent Name of the intent.\n   * @returns {boolean} true if intent has defined entities, else false\n   */\n  hasIntentEntities(intent) {\n    return this.getIntentEntityNames(intent).length > 0;\n  }\n\n  /**\n   * Clear the slot manager.\n   */\n  clear() {\n    this.intents = {};\n  }\n\n  /**\n   * Loads the slot manager content.\n   * @param {Object} src Source content.\n   */\n  load(src) {\n    this.intents = src || {};\n    this.isEmpty = Object.keys(this.intents).length === 0;\n  }\n\n  /**\n   * Returns the slot manager content.\n   * @returns {Object} Slot manager content.\n   */\n  save() {\n    return this.intents;\n  }\n\n  /**\n   * Given an intent return the mandatory slots.\n   * @param {String} intent Name of the intent\n   * @returns {Object} Object with the mandatory slots.\n   */\n  getMandatorySlots(intent) {\n    const result = {};\n    const intentSlots = this.intents[intent];\n    if (intentSlots) {\n      const keys = Object.keys(intentSlots);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const slot = intentSlots[keys[i]];\n        if (slot.mandatory) {\n          result[slot.entity] = slot;\n        }\n      }\n    }\n    return result;\n  }\n  cleanContextEntities(intent, srcContext) {\n    const context = srcContext;\n    if (context.slotFill) {\n      return;\n    }\n    const mandatorySlots = this.getMandatorySlots(intent);\n    const keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach(key => {\n      delete context[key];\n    });\n  }\n  generateEntityAliases(entities) {\n    const aliases = [];\n    const dict = {};\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      if (!dict[entity.entity]) {\n        dict[entity.entity] = [];\n      }\n      aliases[i] = `${entity.entity}_${dict[entity.entity].length}`;\n      dict[entity.entity].push(true);\n    }\n    return aliases;\n  }\n  process(srcResult, srcContext) {\n    const result = srcResult;\n    const context = srcContext;\n    this.cleanContextEntities(result.intent, context);\n    if (context.slotFill) {\n      // if we have slotFill values we set the context to be the same as before\n      result.intent = context.slotFill.intent;\n      result.answer = context.slotFill.answer;\n      result.srcAnswer = context.slotFill.srcAnswer;\n    }\n    if (!result.intent || result.intent === 'None') {\n      // No intent found, we repeat the answer from last time\n      return false;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.entities = [...context.slotFill.entities, ...result.entities];\n    }\n    const mandatorySlots = this.getMandatorySlots(result.intent);\n    let keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      // No mandatory entities defined, we repeat the answer from last time\n      return false;\n    }\n    const aliases = this.generateEntityAliases(result.entities);\n    for (let i = 0, l = result.entities.length; i < l; i += 1) {\n      const entity = result.entities[i];\n      // Remove existing mandatory entities to see what's left\n      delete mandatorySlots[entity.entity];\n      delete mandatorySlots[aliases[i]];\n    }\n    if (context.slotFill && mandatorySlots[context.slotFill.currentSlot]) {\n      // Last time requested slot was not filled by current answer automatically,\n      // so add whole utterance as answer for the requested slow\n      // Do this because automatically parsed entities by builtins like \"duration\" are\n      // added automatically, and we don't want to have duplicated entries in the list\n      result.entities.push({\n        entity: context.slotFill.currentSlot,\n        utteranceText: result.utterance,\n        sourceText: result.utterance,\n        accuracy: 0.95,\n        start: 0,\n        end: result.utterance.length - 1,\n        len: result.utterance.length,\n        isSlotFillingFallback: true\n      });\n      delete mandatorySlots[context.slotFill.currentSlot];\n    }\n    keys = Object.keys(mandatorySlots);\n    if (context.slotFill && context.slotFill.currentSlot) {\n      context.slotFill.latestSlot = context.slotFill.currentSlot;\n    }\n    if (!keys || keys.length === 0) {\n      // All mandatory slots are filled, so we are done. No further questions needed\n      delete result.srcAnswer;\n      return true;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.localeIso2 = context.slotFill.localeIso2;\n    }\n    result.slotFill = {\n      localeIso2: result.localeIso2,\n      intent: result.intent,\n      entities: result.entities,\n      answer: result.answer,\n      srcAnswer: result.srcAnswer\n    };\n    if (context.slotFill && context.slotFill.latestSlot) {\n      result.slotFill.latestSlot = context.slotFill.latestSlot;\n    }\n    const currentSlot = mandatorySlots[keys[0]];\n    result.slotFill.currentSlot = currentSlot.entity;\n    result.srcAnswer = currentSlot.locales[result.localeIso2];\n    context.slotFill = result.slotFill;\n    return true;\n  }\n}\nmodule.exports = SlotManager;","map":{"version":3,"names":["SlotManager","constructor","intents","isEmpty","getSlot","intent","entity","undefined","existsSlot","addSlot","mandatory","arguments","length","questions","locales","updateSlot","slot","Object","assign","removeSlot","addBatch","entities","result","forEach","push","getIntentEntityNames","keys","hasIntentEntities","clear","load","src","save","getMandatorySlots","intentSlots","i","l","cleanContextEntities","srcContext","context","slotFill","mandatorySlots","key","generateEntityAliases","aliases","dict","process","srcResult","answer","srcAnswer","currentSlot","utteranceText","utterance","sourceText","accuracy","start","end","len","isSlotFillingFallback","latestSlot","localeIso2","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/slot/src/slot-manager.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Class for a Slot Manager that takes care of the slot information.\n */\nclass SlotManager {\n  /**\n   * Constructor of the class.\n   */\n  constructor() {\n    this.intents = {};\n    this.isEmpty = true;\n  }\n\n  /**\n   * Returns an slot given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {Object} Slot or undefined if not found.\n   */\n  getSlot(intent, entity) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Indicates if a given slot exists, given the intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @returns {boolean} True if the slot exists, false otherwise.\n   */\n  existsSlot(intent, entity) {\n    return this.getSlot(intent, entity) !== undefined;\n  }\n\n  /**\n   * Adds a new slot for a given intent and entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} [mandatory=false] Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New slot instance.\n   */\n  addSlot(intent, entity, mandatory = false, questions) {\n    this.isEmpty = false;\n    if (!this.intents[intent]) {\n      this.intents[intent] = {};\n    }\n    this.intents[intent][entity] = {\n      intent,\n      entity,\n      mandatory,\n      locales: questions || {},\n    };\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Adds/modifies the parameter of a slot for a given intent and entity.\n   * Slot questions for same locales as already existing will be overwritten.\n   * If the slot for the intent and entity does not exist it fill be created.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   * @param {boolean} mandatory Flag indicating if is mandatory or optional.\n   * @param {Object} [questions] Question to ask when is mandatory, by locale.\n   * @returns {Object} New/Modified slot instance or undefined if not existing\n   */\n  updateSlot(intent, entity, mandatory, questions) {\n    if (!this.intents[intent] || !this.intents[intent][entity]) {\n      return this.addSlot(intent, entity, mandatory, questions);\n    }\n    const slot = this.intents[intent][entity];\n    if (mandatory !== undefined) {\n      // Update mandatory flag only if provided\n      slot.mandatory = mandatory;\n    }\n    slot.locales = Object.assign(slot.locales, questions);\n    return this.intents[intent][entity];\n  }\n\n  /**\n   * Remove an slot given the intent and the entity.\n   * @param {String} intent Name of the intent.\n   * @param {String} entity Name of the entity.\n   */\n  removeSlot(intent, entity) {\n    if (this.intents[intent]) {\n      delete this.intents[intent][entity];\n    }\n  }\n\n  /**\n   * Add several entities if they don't exists.\n   * @param {String} intent Name of the intent.\n   * @param {String[]} entities List of entities.\n   * @returns {Object[]} Array of resulting entities.\n   */\n  addBatch(intent, entities) {\n    const result = [];\n    if (entities && entities.length > 0) {\n      entities.forEach((entity) => {\n        let slot = this.getSlot(intent, entity);\n        if (!slot) {\n          slot = this.addSlot(intent, entity);\n        }\n        result.push(slot);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Given an intent, return the array of entity names of this intent.\n   * @param {String} intent Name of the intent.\n   * @returns {String[]} Array of entity names of the intent.\n   */\n  getIntentEntityNames(intent) {\n    if (!this.intents[intent]) {\n      return undefined;\n    }\n    return Object.keys(this.intents[intent]);\n  }\n\n  /**\n   * Given an intent return the information if the intent has entities defined\n   *\n   * @param {String} intent Name of the intent.\n   * @returns {boolean} true if intent has defined entities, else false\n   */\n  hasIntentEntities(intent) {\n    return this.getIntentEntityNames(intent).length > 0;\n  }\n\n  /**\n   * Clear the slot manager.\n   */\n  clear() {\n    this.intents = {};\n  }\n\n  /**\n   * Loads the slot manager content.\n   * @param {Object} src Source content.\n   */\n  load(src) {\n    this.intents = src || {};\n    this.isEmpty = Object.keys(this.intents).length === 0;\n  }\n\n  /**\n   * Returns the slot manager content.\n   * @returns {Object} Slot manager content.\n   */\n  save() {\n    return this.intents;\n  }\n\n  /**\n   * Given an intent return the mandatory slots.\n   * @param {String} intent Name of the intent\n   * @returns {Object} Object with the mandatory slots.\n   */\n  getMandatorySlots(intent) {\n    const result = {};\n    const intentSlots = this.intents[intent];\n    if (intentSlots) {\n      const keys = Object.keys(intentSlots);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const slot = intentSlots[keys[i]];\n        if (slot.mandatory) {\n          result[slot.entity] = slot;\n        }\n      }\n    }\n    return result;\n  }\n\n  cleanContextEntities(intent, srcContext) {\n    const context = srcContext;\n    if (context.slotFill) {\n      return;\n    }\n    const mandatorySlots = this.getMandatorySlots(intent);\n    const keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach((key) => {\n      delete context[key];\n    });\n  }\n\n  generateEntityAliases(entities) {\n    const aliases = [];\n    const dict = {};\n    for (let i = 0; i < entities.length; i += 1) {\n      const entity = entities[i];\n      if (!dict[entity.entity]) {\n        dict[entity.entity] = [];\n      }\n      aliases[i] = `${entity.entity}_${dict[entity.entity].length}`;\n      dict[entity.entity].push(true);\n    }\n    return aliases;\n  }\n\n  process(srcResult, srcContext) {\n    const result = srcResult;\n    const context = srcContext;\n    this.cleanContextEntities(result.intent, context);\n    if (context.slotFill) {\n      // if we have slotFill values we set the context to be the same as before\n      result.intent = context.slotFill.intent;\n      result.answer = context.slotFill.answer;\n      result.srcAnswer = context.slotFill.srcAnswer;\n    }\n    if (!result.intent || result.intent === 'None') {\n      // No intent found, we repeat the answer from last time\n      return false;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.entities = [...context.slotFill.entities, ...result.entities];\n    }\n    const mandatorySlots = this.getMandatorySlots(result.intent);\n    let keys = Object.keys(mandatorySlots);\n    if (keys.length === 0) {\n      // No mandatory entities defined, we repeat the answer from last time\n      return false;\n    }\n    const aliases = this.generateEntityAliases(result.entities);\n    for (let i = 0, l = result.entities.length; i < l; i += 1) {\n      const entity = result.entities[i];\n      // Remove existing mandatory entities to see what's left\n      delete mandatorySlots[entity.entity];\n      delete mandatorySlots[aliases[i]];\n    }\n    if (context.slotFill && mandatorySlots[context.slotFill.currentSlot]) {\n      // Last time requested slot was not filled by current answer automatically,\n      // so add whole utterance as answer for the requested slow\n      // Do this because automatically parsed entities by builtins like \"duration\" are\n      // added automatically, and we don't want to have duplicated entries in the list\n      result.entities.push({\n        entity: context.slotFill.currentSlot,\n        utteranceText: result.utterance,\n        sourceText: result.utterance,\n        accuracy: 0.95,\n        start: 0,\n        end: result.utterance.length - 1,\n        len: result.utterance.length,\n        isSlotFillingFallback: true,\n      });\n      delete mandatorySlots[context.slotFill.currentSlot];\n    }\n    keys = Object.keys(mandatorySlots);\n    if (context.slotFill && context.slotFill.currentSlot) {\n      context.slotFill.latestSlot = context.slotFill.currentSlot;\n    }\n    if (!keys || keys.length === 0) {\n      // All mandatory slots are filled, so we are done. No further questions needed\n      delete result.srcAnswer;\n      return true;\n    }\n    if (context.slotFill && context.slotFill.intent === result.intent) {\n      result.localeIso2 = context.slotFill.localeIso2;\n    }\n    result.slotFill = {\n      localeIso2: result.localeIso2,\n      intent: result.intent,\n      entities: result.entities,\n      answer: result.answer,\n      srcAnswer: result.srcAnswer,\n    };\n    if (context.slotFill && context.slotFill.latestSlot) {\n      result.slotFill.latestSlot = context.slotFill.latestSlot;\n    }\n    const currentSlot = mandatorySlots[keys[0]];\n    result.slotFill.currentSlot = currentSlot.entity;\n    result.srcAnswer = currentSlot.locales[result.localeIso2];\n    context.slotFill = result.slotFill;\n    return true;\n  }\n}\n\nmodule.exports = SlotManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}