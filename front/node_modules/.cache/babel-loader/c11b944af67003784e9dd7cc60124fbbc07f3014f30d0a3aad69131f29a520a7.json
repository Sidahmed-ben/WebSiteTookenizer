{"ast":null,"code":"/* eslint-disable */\n// Copyright (c) 2012 Chris Geiersbach\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n// This component as adapted from node-ole-doc, available at:\n// https://github.com/atariman486/node-ole-doc.\n//\n// WARNING: This embedded component will be removed in a future\n// release. It is only included as there are some fixes which\n// are not yet pushed into the npm distribution of node-ole-doc.\n\nvar fs = require('fs');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar async = require('async');\nvar _ = require('underscore');\nvar es = require('event-stream');\nfunction Header() {}\n;\nHeader.ole_id = new Buffer('D0CF11E0A1B11AE1', 'hex');\nHeader.prototype.load = function (buffer) {\n  var i;\n  for (i = 0; i < 8; i++) {\n    if (Header.ole_id[i] != buffer[i]) return false;\n  }\n  this.secSize = 1 << buffer.readInt16LE(30); // Size of sectors\n  this.shortSecSize = 1 << buffer.readInt16LE(32); // Size of short sectors\n  this.SATSize = buffer.readInt32LE(44); // Number of sectors used for the Sector Allocation Table\n  this.dirSecId = buffer.readInt32LE(48); // Starting Sec ID of the directory stream\n  this.shortStreamMax = buffer.readInt32LE(56); // Maximum size of a short stream\n  this.SSATSecId = buffer.readInt32LE(60); // Starting Sec ID of the Short Sector Allocation Table\n  this.SSATSize = buffer.readInt32LE(64); // Number of sectors used for the Short Sector Allocation Table\n  this.MSATSecId = buffer.readInt32LE(68); // Starting Sec ID of the Master Sector Allocation Table\n  this.MSATSize = buffer.readInt32LE(72); // Number of sectors used for the Master Sector Allocation Table\n\n  // The first 109 sectors of the MSAT\n  this.partialMSAT = new Array(109);\n  for (i = 0; i < 109; i++) this.partialMSAT[i] = buffer.readInt32LE(76 + i * 4);\n  return true;\n};\nfunction AllocationTable(doc) {\n  this._doc = doc;\n}\nAllocationTable.SecIdFree = -1;\nAllocationTable.SecIdEndOfChain = -2;\nAllocationTable.SecIdSAT = -3;\nAllocationTable.SecIdMSAT = -4;\nAllocationTable.prototype.load = function (secIds, callback) {\n  var self = this;\n  var doc = self._doc;\n  var header = doc._header;\n  self._table = new Array(secIds.length * (header.secSize / 4));\n  doc._readSectors(secIds, function (buffer) {\n    var i;\n    for (i = 0; i < buffer.length / 4; i++) {\n      self._table[i] = buffer.readInt32LE(i * 4);\n    }\n    callback();\n  });\n};\nAllocationTable.prototype.getSecIdChain = function (startSecId) {\n  var secId = startSecId;\n  var secIds = [];\n  while (secId > AllocationTable.SecIdFree) {\n    secIds.push(secId);\n    var secIdPrior = secId;\n    secId = this._table[secId];\n    if (secId === secIdPrior) {\n      // this will cause a deadlock and a out of memory error\n      break;\n    }\n  }\n  return secIds;\n};\nfunction DirectoryTree(doc) {\n  this._doc = doc;\n}\nDirectoryTree.EntryTypeEmpty = 0;\nDirectoryTree.EntryTypeStorage = 1;\nDirectoryTree.EntryTypeStream = 2;\nDirectoryTree.EntryTypeRoot = 5;\nDirectoryTree.NodeColorRed = 0;\nDirectoryTree.NodeColorBlack = 1;\nDirectoryTree.Leaf = -1;\nDirectoryTree.prototype.load = function (secIds, callback) {\n  var self = this;\n  var doc = this._doc;\n  doc._readSectors(secIds, function (buffer) {\n    var count = buffer.length / 128;\n    self._entries = new Array(count);\n    var i = 0;\n    for (i = 0; i < count; i++) {\n      var offset = i * 128;\n      var nameLength = Math.max(buffer.readInt16LE(64 + offset) - 1, 0);\n      var entry = {};\n      entry.name = buffer.toString('utf16le', 0 + offset, nameLength + offset);\n      entry.type = buffer.readInt8(66 + offset);\n      entry.nodeColor = buffer.readInt8(67 + offset);\n      entry.left = buffer.readInt32LE(68 + offset);\n      entry.right = buffer.readInt32LE(72 + offset);\n      entry.storageDirId = buffer.readInt32LE(76 + offset);\n      entry.secId = buffer.readInt32LE(116 + offset);\n      entry.size = buffer.readInt32LE(120 + offset);\n      self._entries[i] = entry;\n    }\n    self.root = _.find(self._entries, function (entry) {\n      return entry.type === DirectoryTree.EntryTypeRoot;\n    });\n    self._buildHierarchy(self.root);\n    callback();\n  });\n};\nDirectoryTree.prototype._buildHierarchy = function (storageEntry) {\n  var self = this;\n  var childIds = this._getChildIds(storageEntry);\n  storageEntry.storages = {};\n  storageEntry.streams = {};\n  _.each(childIds, function (childId) {\n    var childEntry = self._entries[childId];\n    var name = childEntry.name;\n    if (childEntry.type === DirectoryTree.EntryTypeStorage) {\n      storageEntry.storages[name] = childEntry;\n    }\n    if (childEntry.type === DirectoryTree.EntryTypeStream) {\n      storageEntry.streams[name] = childEntry;\n    }\n  });\n  _.each(storageEntry.storages, function (childStorageEntry) {\n    self._buildHierarchy(childStorageEntry);\n  });\n};\nDirectoryTree.prototype._getChildIds = function (storageEntry) {\n  var self = this;\n  var childIds = [];\n  function visit(visitEntry) {\n    if (visitEntry.left !== DirectoryTree.Leaf) {\n      childIds.push(visitEntry.left);\n      visit(self._entries[visitEntry.left]);\n    }\n    if (visitEntry.right !== DirectoryTree.Leaf) {\n      childIds.push(visitEntry.right);\n      visit(self._entries[visitEntry.right]);\n    }\n  }\n  ;\n  if (storageEntry.storageDirId > -1) {\n    childIds.push(storageEntry.storageDirId);\n    var rootChildEntry = self._entries[storageEntry.storageDirId];\n    visit(rootChildEntry);\n  }\n  return childIds;\n};\nfunction Storage(doc, dirEntry) {\n  this._doc = doc;\n  this._dirEntry = dirEntry;\n}\n;\nStorage.prototype.storage = function (storageName) {\n  return new Storage(this._doc, this._dirEntry.storages[storageName]);\n};\nStorage.prototype.stream = function (streamName) {\n  var streamEntry = this._dirEntry.streams[streamName];\n  if (!streamEntry) return null;\n  var self = this;\n  var doc = self._doc;\n  var bytes = streamEntry.size;\n  var allocationTable = doc._SAT;\n  var shortStream = false;\n  if (bytes < doc._header.shortStreamMax) {\n    shortStream = true;\n    allocationTable = doc._SSAT;\n  }\n  var secIds = allocationTable.getSecIdChain(streamEntry.secId);\n  return es.readable(function (i, callback) {\n    var stream = this; // Function called in context of stream\n\n    if (i >= secIds.length) {\n      stream.emit('end');\n      return;\n    }\n    function sectorCallback(buffer) {\n      if (bytes - buffer.length < 0) {\n        buffer = buffer.slice(0, bytes);\n      }\n      bytes -= buffer.length;\n      stream.emit('data', buffer);\n      callback();\n    }\n    ;\n    if (shortStream) {\n      doc._readShortSector(secIds[i], sectorCallback);\n    } else {\n      doc._readSector(secIds[i], sectorCallback);\n    }\n  });\n};\n\n//function Stream( doc, dirEntry ) {\n//   this._doc = doc;\n//   this._dirEntry = dirEntry;\n//};\n\nfunction OleCompoundDoc(filename) {\n  EventEmitter.call(this);\n  this._filename = filename;\n  this._skipBytes = 0;\n}\n;\nutil.inherits(OleCompoundDoc, EventEmitter);\nOleCompoundDoc.prototype.read = function () {\n  this._read();\n};\nOleCompoundDoc.prototype.readWithCustomHeader = function (size, callback) {\n  this._skipBytes = size;\n  this._customHeaderCallback = callback;\n  this._read();\n};\nOleCompoundDoc.prototype._read = function () {\n  var series = [this._openFile.bind(this), this._readHeader.bind(this), this._readMSAT.bind(this), this._readSAT.bind(this), this._readSSAT.bind(this), this._readDirectoryTree.bind(this)];\n  if (this._skipBytes != 0) {\n    series.splice(1, 0, this._readCustomHeader.bind(this));\n  }\n  async.series(series, function (err) {\n    if (err) {\n      this.emit('err', err);\n      return;\n    }\n    this.emit('ready');\n  }.bind(this));\n};\nOleCompoundDoc.prototype._openFile = function (callback) {\n  var self = this;\n  fs.open(this._filename, 'r', 0o666, function (err, fd) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n    self._fd = fd;\n    callback();\n  });\n};\nOleCompoundDoc.prototype._readCustomHeader = function (callback) {\n  var self = this;\n  var buffer = new Buffer(this._skipBytes);\n  fs.read(self._fd, buffer, 0, this._skipBytes, 0, function (err, bytesRead, buffer) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n    if (!self._customHeaderCallback(buffer)) return;\n    callback();\n  });\n};\nOleCompoundDoc.prototype._readHeader = function (callback) {\n  var self = this;\n  var buffer = new Buffer(512);\n  fs.read(this._fd, buffer, 0, 512, 0 + this._skipBytes, function (err, bytesRead, buffer) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n    var header = self._header = new Header();\n    if (!header.load(buffer)) {\n      self.emit('err', new Error(\"Not a valid compound document\"));\n      return;\n    }\n    callback();\n  });\n};\nOleCompoundDoc.prototype._readMSAT = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._MSAT = header.partialMSAT.slice(0);\n  self._MSAT.length = header.SATSize;\n  if (header.SATSize <= 109 || header.MSATSize == 0) {\n    callback();\n    return;\n  }\n  var buffer = new Buffer(header.secSize);\n  var currMSATIndex = 109;\n  var i = 0;\n  var secId = header.MSATSecId;\n  async.whilst(function () {\n    return i < header.MSATSize;\n  }, function (whilstCallback) {\n    self._readSector(secId, function (sectorBuffer) {\n      var s;\n      for (s = 0; s < header.secSize - 4; s += 4) {\n        if (currMSATIndex >= header.SATSize) break;else self._MSAT[currMSATIndex] = sectorBuffer.readInt32LE(s);\n        currMSATIndex++;\n      }\n      secId = sectorBuffer.readInt32LE(header.secSize - 4);\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n    callback();\n  });\n};\nOleCompoundDoc.prototype._readSector = function (secId, callback) {\n  this._readSectors([secId], callback);\n};\nOleCompoundDoc.prototype._readSectors = function (secIds, callback) {\n  var self = this;\n  var header = self._header;\n  var buffer = new Buffer(secIds.length * header.secSize);\n  var i = 0;\n  async.whilst(function () {\n    return i < secIds.length;\n  }, function (whilstCallback) {\n    var bufferOffset = i * header.secSize;\n    var fileOffset = self._getFileOffsetForSec(secIds[i]);\n    fs.read(self._fd, buffer, bufferOffset, header.secSize, fileOffset, function (err, bytesRead, buffer) {\n      if (err) {\n        self.emit('err', err);\n        return;\n      }\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n    }\n    callback(buffer);\n  });\n};\nOleCompoundDoc.prototype._readShortSector = function (secId, callback) {\n  this._readShortSectors([secId], callback);\n};\nOleCompoundDoc.prototype._readShortSectors = function (secIds, callback) {\n  var self = this;\n  var header = self._header;\n  var buffer = new Buffer(secIds.length * header.shortSecSize);\n  var i = 0;\n  async.whilst(function () {\n    return i < secIds.length;\n  }, function (whilstCallback) {\n    var bufferOffset = i * header.shortSecSize;\n    var fileOffset = self._getFileOffsetForShortSec(secIds[i]);\n    fs.read(self._fd, buffer, bufferOffset, header.shortSecSize, fileOffset, function (err, bytesRead, buffer) {\n      if (err) {\n        self.emit('err', err);\n        return;\n      }\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n    }\n    callback(buffer);\n  });\n};\nOleCompoundDoc.prototype._readSAT = function (callback) {\n  var self = this;\n  self._SAT = new AllocationTable(self);\n  self._SAT.load(self._MSAT, callback);\n};\nOleCompoundDoc.prototype._readSSAT = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._SSAT = new AllocationTable(self);\n  var secIds = self._SAT.getSecIdChain(header.SSATSecId);\n  if (secIds.length != header.SSATSize) {\n    self.emit('err', new Error(\"Invalid Short Sector Allocation Table\"));\n    return;\n  }\n  self._SSAT.load(secIds, callback);\n};\nOleCompoundDoc.prototype._readDirectoryTree = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._directoryTree = new DirectoryTree(this);\n  var secIds = self._SAT.getSecIdChain(header.dirSecId);\n  self._directoryTree.load(secIds, function () {\n    var rootEntry = self._directoryTree.root;\n    self._rootStorage = new Storage(self, rootEntry);\n    self._shortStreamSecIds = self._SAT.getSecIdChain(rootEntry.secId);\n    callback();\n  });\n};\nOleCompoundDoc.prototype._getFileOffsetForSec = function (secId) {\n  var secSize = this._header.secSize;\n  return this._skipBytes + (secId + 1) * secSize; // Skip past the header sector\n};\n\nOleCompoundDoc.prototype._getFileOffsetForShortSec = function (shortSecId) {\n  var shortSecSize = this._header.shortSecSize;\n  var shortStreamOffset = shortSecId * shortSecSize;\n  var secSize = this._header.secSize;\n  var secIdIndex = Math.floor(shortStreamOffset / secSize);\n  var secOffset = shortStreamOffset % secSize;\n  var secId = this._shortStreamSecIds[secIdIndex];\n  return this._getFileOffsetForSec(secId) + secOffset;\n};\nOleCompoundDoc.prototype.storage = function (storageName) {\n  return this._rootStorage.storage(storageName);\n};\nOleCompoundDoc.prototype.stream = function (streamName) {\n  return this._rootStorage.stream(streamName);\n};\nexports.OleCompoundDoc = OleCompoundDoc;","map":{"version":3,"names":["fs","require","EventEmitter","util","async","_","es","Header","ole_id","Buffer","prototype","load","buffer","i","secSize","readInt16LE","shortSecSize","SATSize","readInt32LE","dirSecId","shortStreamMax","SSATSecId","SSATSize","MSATSecId","MSATSize","partialMSAT","Array","AllocationTable","doc","_doc","SecIdFree","SecIdEndOfChain","SecIdSAT","SecIdMSAT","secIds","callback","self","header","_header","_table","length","_readSectors","getSecIdChain","startSecId","secId","push","secIdPrior","DirectoryTree","EntryTypeEmpty","EntryTypeStorage","EntryTypeStream","EntryTypeRoot","NodeColorRed","NodeColorBlack","Leaf","count","_entries","offset","nameLength","Math","max","entry","name","toString","type","readInt8","nodeColor","left","right","storageDirId","size","root","find","_buildHierarchy","storageEntry","childIds","_getChildIds","storages","streams","each","childId","childEntry","childStorageEntry","visit","visitEntry","rootChildEntry","Storage","dirEntry","_dirEntry","storage","storageName","stream","streamName","streamEntry","bytes","allocationTable","_SAT","shortStream","_SSAT","readable","emit","sectorCallback","slice","_readShortSector","_readSector","OleCompoundDoc","filename","call","_filename","_skipBytes","inherits","read","_read","readWithCustomHeader","_customHeaderCallback","series","_openFile","bind","_readHeader","_readMSAT","_readSAT","_readSSAT","_readDirectoryTree","splice","_readCustomHeader","err","open","fd","_fd","bytesRead","Error","_MSAT","currMSATIndex","whilst","whilstCallback","sectorBuffer","s","bufferOffset","fileOffset","_getFileOffsetForSec","_readShortSectors","_getFileOffsetForShortSec","_directoryTree","rootEntry","_rootStorage","_shortStreamSecIds","shortSecId","shortStreamOffset","secIdIndex","floor","secOffset","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/word-extractor/lib/ole-doc.js"],"sourcesContent":["/* eslint-disable */\n// Copyright (c) 2012 Chris Geiersbach\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n// This component as adapted from node-ole-doc, available at:\n// https://github.com/atariman486/node-ole-doc.\n//\n// WARNING: This embedded component will be removed in a future\n// release. It is only included as there are some fixes which\n// are not yet pushed into the npm distribution of node-ole-doc.\n\nvar fs = require('fs');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar async = require('async');\nvar _ = require('underscore');\nvar es = require('event-stream');\n\nfunction Header() {\n};\n\nHeader.ole_id = new Buffer( 'D0CF11E0A1B11AE1', 'hex' );\n\nHeader.prototype.load = function( buffer ) {\n   var i;\n   for( i = 0; i < 8; i++ ) {\n      if ( Header.ole_id[i] != buffer[i] )\n         return false;\n   }\n\n   this.secSize        = 1 << buffer.readInt16LE( 30 );  // Size of sectors\n   this.shortSecSize   = 1 << buffer.readInt16LE( 32 );  // Size of short sectors\n   this.SATSize        =      buffer.readInt32LE( 44 );  // Number of sectors used for the Sector Allocation Table\n   this.dirSecId       =      buffer.readInt32LE( 48 );  // Starting Sec ID of the directory stream\n   this.shortStreamMax =      buffer.readInt32LE( 56 );  // Maximum size of a short stream\n   this.SSATSecId      =      buffer.readInt32LE( 60 );  // Starting Sec ID of the Short Sector Allocation Table\n   this.SSATSize       =      buffer.readInt32LE( 64 );  // Number of sectors used for the Short Sector Allocation Table\n   this.MSATSecId      =      buffer.readInt32LE( 68 );  // Starting Sec ID of the Master Sector Allocation Table\n   this.MSATSize       =      buffer.readInt32LE( 72 );  // Number of sectors used for the Master Sector Allocation Table\n\n   // The first 109 sectors of the MSAT\n   this.partialMSAT = new Array(109);\n   for( i = 0; i < 109; i++ )\n      this.partialMSAT[i] = buffer.readInt32LE( 76 + i * 4 );\n\n   return true;\n};\n\nfunction AllocationTable(doc) {\n   this._doc = doc;\n}\n\nAllocationTable.SecIdFree       = -1;\nAllocationTable.SecIdEndOfChain = -2;\nAllocationTable.SecIdSAT        = -3;\nAllocationTable.SecIdMSAT       = -4;\n\nAllocationTable.prototype.load = function(secIds, callback) {\n   var self = this;\n   var doc = self._doc;\n   var header = doc._header;\n\n   self._table = new Array( secIds.length * ( header.secSize / 4 ) );\n\n   doc._readSectors( secIds, function(buffer) {\n      var i;\n      for ( i = 0; i < buffer.length / 4; i++ ) {\n         self._table[i] = buffer.readInt32LE( i * 4 );\n      }\n      callback();\n   });\n};\n\nAllocationTable.prototype.getSecIdChain = function(startSecId) {\n   var secId = startSecId;\n   var secIds = [];\n   while ( secId > AllocationTable.SecIdFree ) {\n      secIds.push( secId );\n      var secIdPrior = secId;\n      secId = this._table[secId];\n      if (secId === secIdPrior) { // this will cause a deadlock and a out of memory error\n         break;\n      }\n   }\n\n   return secIds;\n};\n\nfunction DirectoryTree(doc) {\n   this._doc = doc;\n}\n\nDirectoryTree.EntryTypeEmpty   = 0;\nDirectoryTree.EntryTypeStorage = 1;\nDirectoryTree.EntryTypeStream  = 2;\nDirectoryTree.EntryTypeRoot    = 5;\n\nDirectoryTree.NodeColorRed   = 0;\nDirectoryTree.NodeColorBlack = 1;\n\nDirectoryTree.Leaf = -1;\n\nDirectoryTree.prototype.load = function( secIds, callback ) {\n   var self = this;\n   var doc = this._doc;\n\n   doc._readSectors( secIds, function(buffer) {\n\n      var count = buffer.length / 128;\n      self._entries = new Array( count );\n      var i = 0;\n      for( i = 0; i < count; i++ )\n      {\n         var offset = i * 128;\n\n         var nameLength = Math.max( buffer.readInt16LE( 64 + offset ) - 1, 0 );\n\n         var entry = {};\n         entry.name = buffer.toString('utf16le', 0 + offset, nameLength + offset );\n         entry.type = buffer.readInt8( 66 + offset );\n         entry.nodeColor = buffer.readInt8( 67 + offset );\n         entry.left = buffer.readInt32LE( 68 + offset );\n         entry.right = buffer.readInt32LE( 72 + offset );\n         entry.storageDirId = buffer.readInt32LE( 76 + offset );\n         entry.secId = buffer.readInt32LE( 116 + offset );\n         entry.size = buffer.readInt32LE( 120 + offset );\n\n         self._entries[i] = entry;\n      }\n\n      self.root = _.find( self._entries, function(entry) {\n         return entry.type === DirectoryTree.EntryTypeRoot;\n      });\n\n      self._buildHierarchy( self.root );\n\n      callback();\n   });\n};\n\nDirectoryTree.prototype._buildHierarchy = function( storageEntry ) {\n   var self = this;\n   var childIds = this._getChildIds( storageEntry );\n\n   storageEntry.storages = {};\n   storageEntry.streams  = {};\n\n   _.each( childIds, function( childId ) {\n      var childEntry = self._entries[childId];\n      var name = childEntry.name;\n      if ( childEntry.type === DirectoryTree.EntryTypeStorage ) {\n         storageEntry.storages[name] = childEntry;\n      }\n      if ( childEntry.type === DirectoryTree.EntryTypeStream ) {\n         storageEntry.streams[name] = childEntry;\n      }\n   });\n\n   _.each( storageEntry.storages, function( childStorageEntry ) {\n      self._buildHierarchy( childStorageEntry );\n   });\n};\n\nDirectoryTree.prototype._getChildIds = function( storageEntry ) {\n   var self = this;\n   var childIds = [];\n\n   function visit( visitEntry ) {\n      if ( visitEntry.left !== DirectoryTree.Leaf ) {\n         childIds.push( visitEntry.left );\n         visit( self._entries[visitEntry.left] );\n      }\n      if ( visitEntry.right !== DirectoryTree.Leaf ) {\n         childIds.push( visitEntry.right );\n         visit( self._entries[visitEntry.right] );\n      }\n   };\n\n   if ( storageEntry.storageDirId > -1 ) {\n      childIds.push( storageEntry.storageDirId );\n      var rootChildEntry = self._entries[storageEntry.storageDirId];\n      visit( rootChildEntry );\n   }\n\n   return childIds;\n};\n\nfunction Storage( doc, dirEntry ) {\n   this._doc = doc;\n   this._dirEntry = dirEntry;\n};\n\nStorage.prototype.storage = function( storageName ) {\n   return new Storage( this._doc, this._dirEntry.storages[ storageName ] );\n};\n\nStorage.prototype.stream = function( streamName ) {\n   var streamEntry = this._dirEntry.streams[streamName];\n   if ( !streamEntry )\n      return null;\n\n   var self = this;\n   var doc  = self._doc;\n   var bytes = streamEntry.size;\n\n   var allocationTable = doc._SAT;\n   var shortStream = false;\n   if ( bytes < doc._header.shortStreamMax ) {\n      shortStream = true;\n      allocationTable = doc._SSAT;\n   }\n\n   var secIds = allocationTable.getSecIdChain( streamEntry.secId );\n\n   return es.readable( function( i, callback ) {\n      var stream = this;  // Function called in context of stream\n\n      if ( i >= secIds.length ) {\n         stream.emit('end');\n         return;\n      }\n\n      function sectorCallback(buffer) {\n         if ( bytes - buffer.length < 0 ) {\n            buffer = buffer.slice( 0, bytes );\n         }\n\n         bytes -= buffer.length;\n         stream.emit('data', buffer);\n         callback();\n      };\n\n      if ( shortStream ) {\n         doc._readShortSector( secIds[i], sectorCallback );\n      }\n      else {\n         doc._readSector( secIds[i], sectorCallback );\n      }\n   });\n};\n\n//function Stream( doc, dirEntry ) {\n//   this._doc = doc;\n//   this._dirEntry = dirEntry;\n//};\n\nfunction OleCompoundDoc( filename ) {\n   EventEmitter.call(this);\n\n   this._filename = filename;\n   this._skipBytes = 0;\n};\nutil.inherits(OleCompoundDoc, EventEmitter);\n\nOleCompoundDoc.prototype.read = function() {\n   this._read();\n};\n\nOleCompoundDoc.prototype.readWithCustomHeader = function( size, callback ) {\n   this._skipBytes = size;\n   this._customHeaderCallback = callback;\n   this._read();\n};\n\nOleCompoundDoc.prototype._read = function() {\n   var series = [\n      this._openFile.bind(this),\n      this._readHeader.bind(this),\n      this._readMSAT.bind(this),\n      this._readSAT.bind(this),\n      this._readSSAT.bind(this),\n      this._readDirectoryTree.bind(this)\n   ];\n\n   if ( this._skipBytes != 0 ) {\n      series.splice( 1, 0, this._readCustomHeader.bind(this) );\n   }\n\n   async.series(\n      series,\n      (function(err) {\n         if ( err ) {\n            this.emit('err', err);\n            return;\n         }\n\n         this.emit('ready');\n      }).bind(this)\n   );\n};\n\nOleCompoundDoc.prototype._openFile = function( callback ) {\n   var self = this;\n   fs.open( this._filename, 'r', 0o666, function(err, fd) {\n      if( err ) {\n         self.emit('err', err);\n         return;\n      }\n\n      self._fd = fd;\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readCustomHeader = function(callback) {\n   var self = this;\n   var buffer = new Buffer(this._skipBytes);\n   fs.read( self._fd, buffer, 0, this._skipBytes, 0, function(err, bytesRead, buffer) {\n      if(err) {\n         self.emit('err', err);\n         return;\n      }\n\n      if( !self._customHeaderCallback(buffer) )\n         return;\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readHeader = function(callback) {\n   var self = this;\n   var buffer = new Buffer(512);\n   fs.read( this._fd, buffer, 0, 512, 0 + this._skipBytes, function(err, bytesRead, buffer) {\n      if( err ) {\n         self.emit('err', err);\n         return;\n      }\n\n      var header = self._header = new Header();\n      if ( !header.load( buffer ) ) {\n         self.emit('err', new Error(\"Not a valid compound document\"));\n         return;\n      }\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readMSAT = function(callback) {\n   var self = this;\n   var header = self._header;\n\n   self._MSAT = header.partialMSAT.slice(0);\n   self._MSAT.length = header.SATSize;\n\n   if( header.SATSize <= 109 || header.MSATSize == 0 ) {\n      callback();\n      return;\n   }\n\n   var buffer = new Buffer( header.secSize );\n   var currMSATIndex = 109;\n   var i = 0;\n   var secId = header.MSATSecId;\n\n   async.whilst(\n      function() {\n         return i < header.MSATSize;\n      },\n      function(whilstCallback) {\n         self._readSector(secId, function(sectorBuffer) {\n            var s;\n            for( s = 0; s < header.secSize - 4; s += 4 )\n            {\n               if( currMSATIndex >= header.SATSize )\n                  break;\n               else\n                  self._MSAT[currMSATIndex] = sectorBuffer.readInt32LE( s );\n\n               currMSATIndex++;\n            }\n\n            secId = sectorBuffer.readInt32LE( header.secSize - 4 );\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n            return;\n         }\n\n         callback();\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readSector = function(secId, callback) {\n   this._readSectors( [ secId ], callback );\n};\n\nOleCompoundDoc.prototype._readSectors = function(secIds, callback) {\n   var self = this;\n   var header = self._header;\n   var buffer = new Buffer( secIds.length * header.secSize );\n\n   var i = 0;\n\n   async.whilst(\n      function() {\n         return i < secIds.length;\n      },\n      function(whilstCallback) {\n         var bufferOffset = i * header.secSize;\n         var fileOffset = self._getFileOffsetForSec( secIds[i] );\n         fs.read( self._fd, buffer, bufferOffset, header.secSize, fileOffset, function(err, bytesRead, buffer) {\n            if ( err ) {\n               self.emit('err', err);\n               return;\n            }\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n         }\n         callback(buffer);\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readShortSector = function(secId, callback) {\n   this._readShortSectors( [ secId ], callback );\n};\n\nOleCompoundDoc.prototype._readShortSectors = function(secIds, callback) {\n   var self = this;\n   var header = self._header;\n   var buffer = new Buffer( secIds.length * header.shortSecSize );\n\n   var i = 0;\n\n   async.whilst(\n      function() {\n         return i < secIds.length;\n      },\n      function(whilstCallback) {\n         var bufferOffset = i * header.shortSecSize;\n         var fileOffset = self._getFileOffsetForShortSec( secIds[i] );\n         fs.read( self._fd, buffer, bufferOffset, header.shortSecSize, fileOffset, function(err, bytesRead, buffer) {\n            if ( err ) {\n               self.emit('err', err);\n               return;\n            }\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n         }\n         callback(buffer);\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readSAT = function(callback) {\n   var self = this;\n   self._SAT = new AllocationTable(self);\n\n   self._SAT.load( self._MSAT, callback );\n};\n\nOleCompoundDoc.prototype._readSSAT = function(callback) {\n   var self = this;\n   var header = self._header;\n   self._SSAT = new AllocationTable(self);\n\n   var secIds = self._SAT.getSecIdChain( header.SSATSecId );\n   if ( secIds.length != header.SSATSize ) {\n      self.emit('err', new Error(\"Invalid Short Sector Allocation Table\"));\n      return;\n   }\n\n   self._SSAT.load( secIds, callback);\n};\n\nOleCompoundDoc.prototype._readDirectoryTree = function(callback) {\n   var self = this;\n   var header = self._header;\n\n   self._directoryTree = new DirectoryTree(this);\n\n   var secIds = self._SAT.getSecIdChain( header.dirSecId );\n   self._directoryTree.load( secIds, function() {\n\n      var rootEntry = self._directoryTree.root;\n      self._rootStorage = new Storage( self, rootEntry );\n      self._shortStreamSecIds = self._SAT.getSecIdChain( rootEntry.secId );\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._getFileOffsetForSec = function( secId ) {\n   var secSize = this._header.secSize;\n   return this._skipBytes + (secId + 1) * secSize;  // Skip past the header sector\n};\n\nOleCompoundDoc.prototype._getFileOffsetForShortSec = function( shortSecId ) {\n   var shortSecSize = this._header.shortSecSize;\n   var shortStreamOffset = shortSecId * shortSecSize;\n\n   var secSize = this._header.secSize;\n   var secIdIndex = Math.floor( shortStreamOffset / secSize );\n   var secOffset = shortStreamOffset % secSize;\n   var secId = this._shortStreamSecIds[secIdIndex];\n\n   return this._getFileOffsetForSec( secId ) + secOffset;\n};\n\nOleCompoundDoc.prototype.storage = function( storageName ) {\n   return this._rootStorage.storage( storageName );\n};\n\nOleCompoundDoc.prototype.stream = function( streamName ) {\n   return this._rootStorage.stream( streamName );\n};\n\nexports.OleCompoundDoc = OleCompoundDoc;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}