{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CorpusLookup = require('./corpus-lookup');\nconst defaultSettings = {\n  iterations: 20000,\n  errorThresh: 0.00005,\n  deltaErrorThresh: 0.000001,\n  learningRate: 0.6,\n  momentum: 0.5,\n  alpha: 0.07,\n  log: false\n};\nclass NeuralNetwork {\n  constructor() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.settings = settings;\n    this.applySettings(this.settings, defaultSettings);\n    if (this.settings.log === true) {\n      this.logFn = (status, time) => console.log(`Epoch ${status.iterations} loss ${status.error} time ${time}ms`);\n    } else if (typeof this.settings.log === 'function') {\n      this.logFn = this.settings.log;\n    }\n  }\n  applySettings() {\n    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Object.keys(settings).forEach(key => {\n      if (obj[key] === undefined) {\n        obj[key] = settings[key];\n      }\n    });\n    return obj;\n  }\n  initialize(numInputs, outputNames) {\n    this.perceptronsByName = {};\n    this.perceptrons = [];\n    this.outputs = {};\n    this.numPerceptrons = outputNames.length;\n    for (let i = 0; i < outputNames.length; i += 1) {\n      const name = outputNames[i];\n      this.outputs[name] = 0;\n      const perceptron = {\n        name,\n        id: i,\n        weights: new Float32Array(numInputs),\n        changes: new Float32Array(numInputs),\n        bias: 0\n      };\n      this.perceptrons.push(perceptron);\n      this.perceptronsByName[name] = perceptron;\n    }\n  }\n  runInputPerceptron(perceptron, input) {\n    const sum = input.keys.reduce((prev, key) => prev + input.data[key] * perceptron.weights[key], perceptron.bias);\n    return sum <= 0 ? 0 : this.settings.alpha * sum;\n  }\n  runInput(input) {\n    for (let i = 0; i < this.numPerceptrons; i += 1) {\n      this.outputs[this.perceptrons[i].name] = this.runInputPerceptron(this.perceptrons[i], input);\n    }\n    return this.outputs;\n  }\n  get isRunnable() {\n    return !!this.numPerceptrons;\n  }\n  run(input) {\n    return this.numPerceptrons ? this.runInput(this.lookup.transformInput(input)) : undefined;\n  }\n  prepareCorpus(corpus) {\n    this.lookup = new CorpusLookup();\n    return this.lookup.build(corpus);\n  }\n  verifyIsInitialized() {\n    if (!this.perceptrons) {\n      this.initialize(this.lookup.numInputs, this.lookup.outputLookup.items);\n    }\n  }\n  trainPerceptron(perceptron, data) {\n    const {\n      alpha,\n      momentum\n    } = this.settings;\n    const {\n      changes,\n      weights\n    } = perceptron;\n    let error = 0;\n    for (let i = 0; i < data.length; i += 1) {\n      const {\n        input,\n        output\n      } = data[i];\n      const actualOutput = this.runInputPerceptron(perceptron, input);\n      const expectedOutput = output.data[perceptron.id] || 0;\n      const currentError = expectedOutput - actualOutput;\n      if (currentError) {\n        error += currentError ** 2;\n        const delta = (actualOutput > 0 ? 1 : alpha) * currentError * this.decayLearningRate;\n        for (let j = 0; j < input.keys.length; j += 1) {\n          const key = input.keys[j];\n          const change = delta * input.data[key] + momentum * changes[key];\n          changes[key] = change;\n          weights[key] += change;\n        }\n        perceptron.bias += delta;\n      }\n    }\n    return error;\n  }\n  train(corpus) {\n    if (!corpus || !corpus.length) {\n      return {};\n    }\n    const useNoneFeature = corpus[corpus.length - 1].input.nonefeature !== undefined;\n    if (useNoneFeature) {\n      const intents = {};\n      for (let i = 0; i < corpus.length - 1; i += 1) {\n        const tokens = Object.keys(corpus[i].output);\n        for (let j = 0; j < tokens.length; j += 1) {\n          if (!intents[tokens[j]]) {\n            intents[tokens[j]] = 1;\n          }\n        }\n      }\n      const current = corpus[corpus.length - 1];\n      const keys = Object.keys(intents);\n      for (let i = 0; i < keys.length; i += 1) {\n        current.output[keys[i]] = 0.0000001;\n      }\n    }\n    const data = this.prepareCorpus(corpus);\n    if (!this.status) {\n      this.status = {\n        error: Infinity,\n        deltaError: Infinity,\n        iterations: 0\n      };\n    }\n    this.verifyIsInitialized();\n    const minError = this.settings.errorThresh;\n    const minDelta = this.settings.deltaErrorThresh;\n    while (this.status.iterations < this.settings.iterations && this.status.error > minError && this.status.deltaError > minDelta) {\n      const hrstart = new Date();\n      this.status.iterations += 1;\n      this.decayLearningRate = this.settings.learningRate / (1 + 0.001 * this.status.iterations);\n      const lastError = this.status.error;\n      this.status.error = 0;\n      for (let i = 0; i < this.numPerceptrons; i += 1) {\n        this.status.error += this.trainPerceptron(this.perceptrons[i], data);\n      }\n      this.status.error /= this.numPerceptrons * data.length;\n      this.status.deltaError = Math.abs(this.status.error - lastError);\n      const hrend = new Date();\n      if (this.logFn) {\n        this.logFn(this.status, hrend.getTime() - hrstart.getTime());\n      }\n    }\n    return this.status;\n  }\n  explain(input, intent) {\n    const transformedInput = this.lookup.transformInput(input);\n    const result = {};\n    const intentIndex = this.lookup.outputLookup.dict[intent];\n    if (intentIndex === undefined) {\n      return {};\n    }\n    for (let i = 0; i < transformedInput.keys.length; i += 1) {\n      const key = transformedInput.keys[i];\n      result[this.lookup.inputLookup.items[key]] = this.perceptrons[intentIndex].weights[key];\n    }\n    return {\n      weights: result,\n      bias: this.perceptrons[intentIndex].bias\n    };\n  }\n  toJSON() {\n    const settings = {};\n    const keys = Object.keys(this.settings);\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      if (this.settings[key] !== defaultSettings[key]) {\n        settings[key] = this.settings[key];\n      }\n    }\n    if (!this.lookup) {\n      return {\n        settings\n      };\n    }\n    const features = this.lookup.inputLookup.items;\n    const intents = this.lookup.outputLookup.items;\n    const perceptrons = [];\n    for (let i = 0; i < this.perceptrons.length; i += 1) {\n      const perceptron = this.perceptrons[i];\n      const weights = [...perceptron.weights, perceptron.bias];\n      perceptrons.push(weights);\n    }\n    return {\n      settings,\n      features,\n      intents,\n      perceptrons\n    };\n  }\n  fromJSON(json) {\n    this.settings = this.applySettings({\n      ...defaultSettings,\n      ...json.settings\n    });\n    if (json.features) {\n      this.lookup = new CorpusLookup(json.features, json.intents);\n      this.initialize(json.features.length, json.intents);\n      for (let i = 0; i < this.perceptrons.length; i += 1) {\n        const perceptron = this.perceptrons[i];\n        const data = json.perceptrons[i];\n        perceptron.bias = data[data.length - 1];\n        for (let j = 0; j < json.features.length; j += 1) {\n          perceptron.weights[j] = data[j];\n        }\n      }\n    }\n  }\n}\nmodule.exports = NeuralNetwork;","map":{"version":3,"names":["CorpusLookup","require","defaultSettings","iterations","errorThresh","deltaErrorThresh","learningRate","momentum","alpha","log","NeuralNetwork","constructor","settings","arguments","length","undefined","applySettings","logFn","status","time","console","error","obj","Object","keys","forEach","key","initialize","numInputs","outputNames","perceptronsByName","perceptrons","outputs","numPerceptrons","i","name","perceptron","id","weights","Float32Array","changes","bias","push","runInputPerceptron","input","sum","reduce","prev","data","runInput","isRunnable","run","lookup","transformInput","prepareCorpus","corpus","build","verifyIsInitialized","outputLookup","items","trainPerceptron","output","actualOutput","expectedOutput","currentError","delta","decayLearningRate","j","change","train","useNoneFeature","nonefeature","intents","tokens","current","Infinity","deltaError","minError","minDelta","hrstart","Date","lastError","Math","abs","hrend","getTime","explain","intent","transformedInput","result","intentIndex","dict","inputLookup","toJSON","features","fromJSON","json","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/neural/src/neural-network.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CorpusLookup = require('./corpus-lookup');\n\nconst defaultSettings = {\n  iterations: 20000,\n  errorThresh: 0.00005,\n  deltaErrorThresh: 0.000001,\n  learningRate: 0.6,\n  momentum: 0.5,\n  alpha: 0.07,\n  log: false,\n};\n\nclass NeuralNetwork {\n  constructor(settings = {}) {\n    this.settings = settings;\n    this.applySettings(this.settings, defaultSettings);\n    if (this.settings.log === true) {\n      this.logFn = (status, time) =>\n        console.log(\n          `Epoch ${status.iterations} loss ${status.error} time ${time}ms`\n        );\n    } else if (typeof this.settings.log === 'function') {\n      this.logFn = this.settings.log;\n    }\n  }\n\n  applySettings(obj = {}, settings = {}) {\n    Object.keys(settings).forEach((key) => {\n      if (obj[key] === undefined) {\n        obj[key] = settings[key];\n      }\n    });\n    return obj;\n  }\n\n  initialize(numInputs, outputNames) {\n    this.perceptronsByName = {};\n    this.perceptrons = [];\n    this.outputs = {};\n    this.numPerceptrons = outputNames.length;\n    for (let i = 0; i < outputNames.length; i += 1) {\n      const name = outputNames[i];\n      this.outputs[name] = 0;\n      const perceptron = {\n        name,\n        id: i,\n        weights: new Float32Array(numInputs),\n        changes: new Float32Array(numInputs),\n        bias: 0,\n      };\n      this.perceptrons.push(perceptron);\n      this.perceptronsByName[name] = perceptron;\n    }\n  }\n\n  runInputPerceptron(perceptron, input) {\n    const sum = input.keys.reduce(\n      (prev, key) => prev + input.data[key] * perceptron.weights[key],\n      perceptron.bias\n    );\n    return sum <= 0 ? 0 : this.settings.alpha * sum;\n  }\n\n  runInput(input) {\n    for (let i = 0; i < this.numPerceptrons; i += 1) {\n      this.outputs[this.perceptrons[i].name] = this.runInputPerceptron(\n        this.perceptrons[i],\n        input\n      );\n    }\n    return this.outputs;\n  }\n\n  get isRunnable() {\n    return !!this.numPerceptrons;\n  }\n\n  run(input) {\n    return this.numPerceptrons\n      ? this.runInput(this.lookup.transformInput(input))\n      : undefined;\n  }\n\n  prepareCorpus(corpus) {\n    this.lookup = new CorpusLookup();\n    return this.lookup.build(corpus);\n  }\n\n  verifyIsInitialized() {\n    if (!this.perceptrons) {\n      this.initialize(this.lookup.numInputs, this.lookup.outputLookup.items);\n    }\n  }\n\n  trainPerceptron(perceptron, data) {\n    const { alpha, momentum } = this.settings;\n    const { changes, weights } = perceptron;\n    let error = 0;\n    for (let i = 0; i < data.length; i += 1) {\n      const { input, output } = data[i];\n      const actualOutput = this.runInputPerceptron(perceptron, input);\n      const expectedOutput = output.data[perceptron.id] || 0;\n      const currentError = expectedOutput - actualOutput;\n      if (currentError) {\n        error += currentError ** 2;\n        const delta =\n          (actualOutput > 0 ? 1 : alpha) *\n          currentError *\n          this.decayLearningRate;\n        for (let j = 0; j < input.keys.length; j += 1) {\n          const key = input.keys[j];\n          const change = delta * input.data[key] + momentum * changes[key];\n          changes[key] = change;\n          weights[key] += change;\n        }\n        perceptron.bias += delta;\n      }\n    }\n    return error;\n  }\n\n  train(corpus) {\n    if (!corpus || !corpus.length) {\n      return {};\n    }\n    const useNoneFeature =\n      corpus[corpus.length - 1].input.nonefeature !== undefined;\n    if (useNoneFeature) {\n      const intents = {};\n      for (let i = 0; i < corpus.length - 1; i += 1) {\n        const tokens = Object.keys(corpus[i].output);\n        for (let j = 0; j < tokens.length; j += 1) {\n          if (!intents[tokens[j]]) {\n            intents[tokens[j]] = 1;\n          }\n        }\n      }\n      const current = corpus[corpus.length - 1];\n      const keys = Object.keys(intents);\n      for (let i = 0; i < keys.length; i += 1) {\n        current.output[keys[i]] = 0.0000001;\n      }\n    }\n    const data = this.prepareCorpus(corpus);\n    if (!this.status) {\n      this.status = { error: Infinity, deltaError: Infinity, iterations: 0 };\n    }\n    this.verifyIsInitialized();\n    const minError = this.settings.errorThresh;\n    const minDelta = this.settings.deltaErrorThresh;\n    while (\n      this.status.iterations < this.settings.iterations &&\n      this.status.error > minError &&\n      this.status.deltaError > minDelta\n    ) {\n      const hrstart = new Date();\n      this.status.iterations += 1;\n      this.decayLearningRate =\n        this.settings.learningRate / (1 + 0.001 * this.status.iterations);\n      const lastError = this.status.error;\n      this.status.error = 0;\n      for (let i = 0; i < this.numPerceptrons; i += 1) {\n        this.status.error += this.trainPerceptron(this.perceptrons[i], data);\n      }\n      this.status.error /= this.numPerceptrons * data.length;\n      this.status.deltaError = Math.abs(this.status.error - lastError);\n      const hrend = new Date();\n      if (this.logFn) {\n        this.logFn(this.status, hrend.getTime() - hrstart.getTime());\n      }\n    }\n    return this.status;\n  }\n\n  explain(input, intent) {\n    const transformedInput = this.lookup.transformInput(input);\n    const result = {};\n    const intentIndex = this.lookup.outputLookup.dict[intent];\n    if (intentIndex === undefined) {\n      return {};\n    }\n    for (let i = 0; i < transformedInput.keys.length; i += 1) {\n      const key = transformedInput.keys[i];\n      result[this.lookup.inputLookup.items[key]] =\n        this.perceptrons[intentIndex].weights[key];\n    }\n    return {\n      weights: result,\n      bias: this.perceptrons[intentIndex].bias,\n    };\n  }\n\n  toJSON() {\n    const settings = {};\n    const keys = Object.keys(this.settings);\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      if (this.settings[key] !== defaultSettings[key]) {\n        settings[key] = this.settings[key];\n      }\n    }\n    if (!this.lookup) {\n      return {\n        settings,\n      };\n    }\n    const features = this.lookup.inputLookup.items;\n    const intents = this.lookup.outputLookup.items;\n    const perceptrons = [];\n    for (let i = 0; i < this.perceptrons.length; i += 1) {\n      const perceptron = this.perceptrons[i];\n      const weights = [...perceptron.weights, perceptron.bias];\n      perceptrons.push(weights);\n    }\n    return {\n      settings,\n      features,\n      intents,\n      perceptrons,\n    };\n  }\n\n  fromJSON(json) {\n    this.settings = this.applySettings({\n      ...defaultSettings,\n      ...json.settings,\n    });\n    if (json.features) {\n      this.lookup = new CorpusLookup(json.features, json.intents);\n      this.initialize(json.features.length, json.intents);\n      for (let i = 0; i < this.perceptrons.length; i += 1) {\n        const perceptron = this.perceptrons[i];\n        const data = json.perceptrons[i];\n        perceptron.bias = data[data.length - 1];\n        for (let j = 0; j < json.features.length; j += 1) {\n          perceptron.weights[j] = data[j];\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = NeuralNetwork;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAE/C,MAAMC,eAAe,GAAG;EACtBC,UAAU,EAAE,KAAK;EACjBC,WAAW,EAAE,OAAO;EACpBC,gBAAgB,EAAE,QAAQ;EAC1BC,YAAY,EAAE,GAAG;EACjBC,QAAQ,EAAE,GAAG;EACbC,KAAK,EAAE,IAAI;EACXC,GAAG,EAAE;AACP,CAAC;AAED,MAAMC,aAAa,CAAC;EAClBC,WAAWA,CAAA,EAAgB;IAAA,IAAfC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACvB,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACI,aAAa,CAAC,IAAI,CAACJ,QAAQ,EAAEV,eAAe,CAAC;IAClD,IAAI,IAAI,CAACU,QAAQ,CAACH,GAAG,KAAK,IAAI,EAAE;MAC9B,IAAI,CAACQ,KAAK,GAAG,CAACC,MAAM,EAAEC,IAAI,KACxBC,OAAO,CAACX,GAAG,CACR,SAAQS,MAAM,CAACf,UAAW,SAAQe,MAAM,CAACG,KAAM,SAAQF,IAAK,IAAG,CACjE;IACL,CAAC,MAAM,IAAI,OAAO,IAAI,CAACP,QAAQ,CAACH,GAAG,KAAK,UAAU,EAAE;MAClD,IAAI,CAACQ,KAAK,GAAG,IAAI,CAACL,QAAQ,CAACH,GAAG;IAChC;EACF;EAEAO,aAAaA,CAAA,EAA0B;IAAA,IAAzBM,GAAG,GAAAT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAA,IAAED,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACnCU,MAAM,CAACC,IAAI,CAACZ,QAAQ,CAAC,CAACa,OAAO,CAAEC,GAAG,IAAK;MACrC,IAAIJ,GAAG,CAACI,GAAG,CAAC,KAAKX,SAAS,EAAE;QAC1BO,GAAG,CAACI,GAAG,CAAC,GAAGd,QAAQ,CAACc,GAAG,CAAC;MAC1B;IACF,CAAC,CAAC;IACF,OAAOJ,GAAG;EACZ;EAEAK,UAAUA,CAACC,SAAS,EAAEC,WAAW,EAAE;IACjC,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IAC3B,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACC,cAAc,GAAGJ,WAAW,CAACf,MAAM;IACxC,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,WAAW,CAACf,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;MAC9C,MAAMC,IAAI,GAAGN,WAAW,CAACK,CAAC,CAAC;MAC3B,IAAI,CAACF,OAAO,CAACG,IAAI,CAAC,GAAG,CAAC;MACtB,MAAMC,UAAU,GAAG;QACjBD,IAAI;QACJE,EAAE,EAAEH,CAAC;QACLI,OAAO,EAAE,IAAIC,YAAY,CAACX,SAAS,CAAC;QACpCY,OAAO,EAAE,IAAID,YAAY,CAACX,SAAS,CAAC;QACpCa,IAAI,EAAE;MACR,CAAC;MACD,IAAI,CAACV,WAAW,CAACW,IAAI,CAACN,UAAU,CAAC;MACjC,IAAI,CAACN,iBAAiB,CAACK,IAAI,CAAC,GAAGC,UAAU;IAC3C;EACF;EAEAO,kBAAkBA,CAACP,UAAU,EAAEQ,KAAK,EAAE;IACpC,MAAMC,GAAG,GAAGD,KAAK,CAACpB,IAAI,CAACsB,MAAM,CAC3B,CAACC,IAAI,EAAErB,GAAG,KAAKqB,IAAI,GAAGH,KAAK,CAACI,IAAI,CAACtB,GAAG,CAAC,GAAGU,UAAU,CAACE,OAAO,CAACZ,GAAG,CAAC,EAC/DU,UAAU,CAACK,IAAI,CAChB;IACD,OAAOI,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAACjC,QAAQ,CAACJ,KAAK,GAAGqC,GAAG;EACjD;EAEAI,QAAQA,CAACL,KAAK,EAAE;IACd,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACD,cAAc,EAAEC,CAAC,IAAI,CAAC,EAAE;MAC/C,IAAI,CAACF,OAAO,CAAC,IAAI,CAACD,WAAW,CAACG,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,IAAI,CAACQ,kBAAkB,CAC9D,IAAI,CAACZ,WAAW,CAACG,CAAC,CAAC,EACnBU,KAAK,CACN;IACH;IACA,OAAO,IAAI,CAACZ,OAAO;EACrB;EAEA,IAAIkB,UAAUA,CAAA,EAAG;IACf,OAAO,CAAC,CAAC,IAAI,CAACjB,cAAc;EAC9B;EAEAkB,GAAGA,CAACP,KAAK,EAAE;IACT,OAAO,IAAI,CAACX,cAAc,GACtB,IAAI,CAACgB,QAAQ,CAAC,IAAI,CAACG,MAAM,CAACC,cAAc,CAACT,KAAK,CAAC,CAAC,GAChD7B,SAAS;EACf;EAEAuC,aAAaA,CAACC,MAAM,EAAE;IACpB,IAAI,CAACH,MAAM,GAAG,IAAIpD,YAAY,EAAE;IAChC,OAAO,IAAI,CAACoD,MAAM,CAACI,KAAK,CAACD,MAAM,CAAC;EAClC;EAEAE,mBAAmBA,CAAA,EAAG;IACpB,IAAI,CAAC,IAAI,CAAC1B,WAAW,EAAE;MACrB,IAAI,CAACJ,UAAU,CAAC,IAAI,CAACyB,MAAM,CAACxB,SAAS,EAAE,IAAI,CAACwB,MAAM,CAACM,YAAY,CAACC,KAAK,CAAC;IACxE;EACF;EAEAC,eAAeA,CAACxB,UAAU,EAAEY,IAAI,EAAE;IAChC,MAAM;MAAExC,KAAK;MAAED;IAAS,CAAC,GAAG,IAAI,CAACK,QAAQ;IACzC,MAAM;MAAE4B,OAAO;MAAEF;IAAQ,CAAC,GAAGF,UAAU;IACvC,IAAIf,KAAK,GAAG,CAAC;IACb,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,IAAI,CAAClC,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;MACvC,MAAM;QAAEU,KAAK;QAAEiB;MAAO,CAAC,GAAGb,IAAI,CAACd,CAAC,CAAC;MACjC,MAAM4B,YAAY,GAAG,IAAI,CAACnB,kBAAkB,CAACP,UAAU,EAAEQ,KAAK,CAAC;MAC/D,MAAMmB,cAAc,GAAGF,MAAM,CAACb,IAAI,CAACZ,UAAU,CAACC,EAAE,CAAC,IAAI,CAAC;MACtD,MAAM2B,YAAY,GAAGD,cAAc,GAAGD,YAAY;MAClD,IAAIE,YAAY,EAAE;QAChB3C,KAAK,IAAI2C,YAAY,IAAI,CAAC;QAC1B,MAAMC,KAAK,GACT,CAACH,YAAY,GAAG,CAAC,GAAG,CAAC,GAAGtD,KAAK,IAC7BwD,YAAY,GACZ,IAAI,CAACE,iBAAiB;QACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,KAAK,CAACpB,IAAI,CAACV,MAAM,EAAEqD,CAAC,IAAI,CAAC,EAAE;UAC7C,MAAMzC,GAAG,GAAGkB,KAAK,CAACpB,IAAI,CAAC2C,CAAC,CAAC;UACzB,MAAMC,MAAM,GAAGH,KAAK,GAAGrB,KAAK,CAACI,IAAI,CAACtB,GAAG,CAAC,GAAGnB,QAAQ,GAAGiC,OAAO,CAACd,GAAG,CAAC;UAChEc,OAAO,CAACd,GAAG,CAAC,GAAG0C,MAAM;UACrB9B,OAAO,CAACZ,GAAG,CAAC,IAAI0C,MAAM;QACxB;QACAhC,UAAU,CAACK,IAAI,IAAIwB,KAAK;MAC1B;IACF;IACA,OAAO5C,KAAK;EACd;EAEAgD,KAAKA,CAACd,MAAM,EAAE;IACZ,IAAI,CAACA,MAAM,IAAI,CAACA,MAAM,CAACzC,MAAM,EAAE;MAC7B,OAAO,CAAC,CAAC;IACX;IACA,MAAMwD,cAAc,GAClBf,MAAM,CAACA,MAAM,CAACzC,MAAM,GAAG,CAAC,CAAC,CAAC8B,KAAK,CAAC2B,WAAW,KAAKxD,SAAS;IAC3D,IAAIuD,cAAc,EAAE;MAClB,MAAME,OAAO,GAAG,CAAC,CAAC;MAClB,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,MAAM,CAACzC,MAAM,GAAG,CAAC,EAAEoB,CAAC,IAAI,CAAC,EAAE;QAC7C,MAAMuC,MAAM,GAAGlD,MAAM,CAACC,IAAI,CAAC+B,MAAM,CAACrB,CAAC,CAAC,CAAC2B,MAAM,CAAC;QAC5C,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,MAAM,CAAC3D,MAAM,EAAEqD,CAAC,IAAI,CAAC,EAAE;UACzC,IAAI,CAACK,OAAO,CAACC,MAAM,CAACN,CAAC,CAAC,CAAC,EAAE;YACvBK,OAAO,CAACC,MAAM,CAACN,CAAC,CAAC,CAAC,GAAG,CAAC;UACxB;QACF;MACF;MACA,MAAMO,OAAO,GAAGnB,MAAM,CAACA,MAAM,CAACzC,MAAM,GAAG,CAAC,CAAC;MACzC,MAAMU,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACgD,OAAO,CAAC;MACjC,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,CAACV,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;QACvCwC,OAAO,CAACb,MAAM,CAACrC,IAAI,CAACU,CAAC,CAAC,CAAC,GAAG,SAAS;MACrC;IACF;IACA,MAAMc,IAAI,GAAG,IAAI,CAACM,aAAa,CAACC,MAAM,CAAC;IACvC,IAAI,CAAC,IAAI,CAACrC,MAAM,EAAE;MAChB,IAAI,CAACA,MAAM,GAAG;QAAEG,KAAK,EAAEsD,QAAQ;QAAEC,UAAU,EAAED,QAAQ;QAAExE,UAAU,EAAE;MAAE,CAAC;IACxE;IACA,IAAI,CAACsD,mBAAmB,EAAE;IAC1B,MAAMoB,QAAQ,GAAG,IAAI,CAACjE,QAAQ,CAACR,WAAW;IAC1C,MAAM0E,QAAQ,GAAG,IAAI,CAAClE,QAAQ,CAACP,gBAAgB;IAC/C,OACE,IAAI,CAACa,MAAM,CAACf,UAAU,GAAG,IAAI,CAACS,QAAQ,CAACT,UAAU,IACjD,IAAI,CAACe,MAAM,CAACG,KAAK,GAAGwD,QAAQ,IAC5B,IAAI,CAAC3D,MAAM,CAAC0D,UAAU,GAAGE,QAAQ,EACjC;MACA,MAAMC,OAAO,GAAG,IAAIC,IAAI,EAAE;MAC1B,IAAI,CAAC9D,MAAM,CAACf,UAAU,IAAI,CAAC;MAC3B,IAAI,CAAC+D,iBAAiB,GACpB,IAAI,CAACtD,QAAQ,CAACN,YAAY,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAACY,MAAM,CAACf,UAAU,CAAC;MACnE,MAAM8E,SAAS,GAAG,IAAI,CAAC/D,MAAM,CAACG,KAAK;MACnC,IAAI,CAACH,MAAM,CAACG,KAAK,GAAG,CAAC;MACrB,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACD,cAAc,EAAEC,CAAC,IAAI,CAAC,EAAE;QAC/C,IAAI,CAAChB,MAAM,CAACG,KAAK,IAAI,IAAI,CAACuC,eAAe,CAAC,IAAI,CAAC7B,WAAW,CAACG,CAAC,CAAC,EAAEc,IAAI,CAAC;MACtE;MACA,IAAI,CAAC9B,MAAM,CAACG,KAAK,IAAI,IAAI,CAACY,cAAc,GAAGe,IAAI,CAAClC,MAAM;MACtD,IAAI,CAACI,MAAM,CAAC0D,UAAU,GAAGM,IAAI,CAACC,GAAG,CAAC,IAAI,CAACjE,MAAM,CAACG,KAAK,GAAG4D,SAAS,CAAC;MAChE,MAAMG,KAAK,GAAG,IAAIJ,IAAI,EAAE;MACxB,IAAI,IAAI,CAAC/D,KAAK,EAAE;QACd,IAAI,CAACA,KAAK,CAAC,IAAI,CAACC,MAAM,EAAEkE,KAAK,CAACC,OAAO,EAAE,GAAGN,OAAO,CAACM,OAAO,EAAE,CAAC;MAC9D;IACF;IACA,OAAO,IAAI,CAACnE,MAAM;EACpB;EAEAoE,OAAOA,CAAC1C,KAAK,EAAE2C,MAAM,EAAE;IACrB,MAAMC,gBAAgB,GAAG,IAAI,CAACpC,MAAM,CAACC,cAAc,CAACT,KAAK,CAAC;IAC1D,MAAM6C,MAAM,GAAG,CAAC,CAAC;IACjB,MAAMC,WAAW,GAAG,IAAI,CAACtC,MAAM,CAACM,YAAY,CAACiC,IAAI,CAACJ,MAAM,CAAC;IACzD,IAAIG,WAAW,KAAK3E,SAAS,EAAE;MAC7B,OAAO,CAAC,CAAC;IACX;IACA,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsD,gBAAgB,CAAChE,IAAI,CAACV,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;MACxD,MAAMR,GAAG,GAAG8D,gBAAgB,CAAChE,IAAI,CAACU,CAAC,CAAC;MACpCuD,MAAM,CAAC,IAAI,CAACrC,MAAM,CAACwC,WAAW,CAACjC,KAAK,CAACjC,GAAG,CAAC,CAAC,GACxC,IAAI,CAACK,WAAW,CAAC2D,WAAW,CAAC,CAACpD,OAAO,CAACZ,GAAG,CAAC;IAC9C;IACA,OAAO;MACLY,OAAO,EAAEmD,MAAM;MACfhD,IAAI,EAAE,IAAI,CAACV,WAAW,CAAC2D,WAAW,CAAC,CAACjD;IACtC,CAAC;EACH;EAEAoD,MAAMA,CAAA,EAAG;IACP,MAAMjF,QAAQ,GAAG,CAAC,CAAC;IACnB,MAAMY,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACZ,QAAQ,CAAC;IACvC,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,CAACV,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMR,GAAG,GAAGF,IAAI,CAACU,CAAC,CAAC;MACnB,IAAI,IAAI,CAACtB,QAAQ,CAACc,GAAG,CAAC,KAAKxB,eAAe,CAACwB,GAAG,CAAC,EAAE;QAC/Cd,QAAQ,CAACc,GAAG,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACc,GAAG,CAAC;MACpC;IACF;IACA,IAAI,CAAC,IAAI,CAAC0B,MAAM,EAAE;MAChB,OAAO;QACLxC;MACF,CAAC;IACH;IACA,MAAMkF,QAAQ,GAAG,IAAI,CAAC1C,MAAM,CAACwC,WAAW,CAACjC,KAAK;IAC9C,MAAMa,OAAO,GAAG,IAAI,CAACpB,MAAM,CAACM,YAAY,CAACC,KAAK;IAC9C,MAAM5B,WAAW,GAAG,EAAE;IACtB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,WAAW,CAACjB,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;MACnD,MAAME,UAAU,GAAG,IAAI,CAACL,WAAW,CAACG,CAAC,CAAC;MACtC,MAAMI,OAAO,GAAG,CAAC,GAAGF,UAAU,CAACE,OAAO,EAAEF,UAAU,CAACK,IAAI,CAAC;MACxDV,WAAW,CAACW,IAAI,CAACJ,OAAO,CAAC;IAC3B;IACA,OAAO;MACL1B,QAAQ;MACRkF,QAAQ;MACRtB,OAAO;MACPzC;IACF,CAAC;EACH;EAEAgE,QAAQA,CAACC,IAAI,EAAE;IACb,IAAI,CAACpF,QAAQ,GAAG,IAAI,CAACI,aAAa,CAAC;MACjC,GAAGd,eAAe;MAClB,GAAG8F,IAAI,CAACpF;IACV,CAAC,CAAC;IACF,IAAIoF,IAAI,CAACF,QAAQ,EAAE;MACjB,IAAI,CAAC1C,MAAM,GAAG,IAAIpD,YAAY,CAACgG,IAAI,CAACF,QAAQ,EAAEE,IAAI,CAACxB,OAAO,CAAC;MAC3D,IAAI,CAAC7C,UAAU,CAACqE,IAAI,CAACF,QAAQ,CAAChF,MAAM,EAAEkF,IAAI,CAACxB,OAAO,CAAC;MACnD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,WAAW,CAACjB,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;QACnD,MAAME,UAAU,GAAG,IAAI,CAACL,WAAW,CAACG,CAAC,CAAC;QACtC,MAAMc,IAAI,GAAGgD,IAAI,CAACjE,WAAW,CAACG,CAAC,CAAC;QAChCE,UAAU,CAACK,IAAI,GAAGO,IAAI,CAACA,IAAI,CAAClC,MAAM,GAAG,CAAC,CAAC;QACvC,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,IAAI,CAACF,QAAQ,CAAChF,MAAM,EAAEqD,CAAC,IAAI,CAAC,EAAE;UAChD/B,UAAU,CAACE,OAAO,CAAC6B,CAAC,CAAC,GAAGnB,IAAI,CAACmB,CAAC,CAAC;QACjC;MACF;IACF;EACF;AACF;AAEA8B,MAAM,CAACC,OAAO,GAAGxF,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}