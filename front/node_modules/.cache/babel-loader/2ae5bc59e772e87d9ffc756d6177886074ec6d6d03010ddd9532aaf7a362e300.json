{"ast":null,"code":"/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nconst {\n  Buffer\n} = require('buffer');\nconst oleDoc = require('./ole-doc').OleCompoundDoc;\nconst filters = require('./filters'); // eslint-disable-line no-unused-vars\nconst translations = require('./translations'); // eslint-disable-line no-unused-vars\n\nconst Document = require('./document');\nvar WordExtractor = function () {\n  let streamBuffer = undefined;\n  let extractDocument = undefined;\n  let documentStream = undefined;\n  let writeBookmarks = undefined;\n  let writePieces = undefined;\n  let extractWordDocument = undefined;\n  let getPiece = undefined;\n  let addText = undefined;\n  let addUnicodeText = undefined;\n  WordExtractor = class WordExtractor {\n    static initClass() {\n      //# Given an OLE stream, returns all the data in a buffer,\n      //# as a promise.\n      streamBuffer = stream => new Promise(function (resolve, reject) {\n        const chunks = [];\n        stream.on('data', chunk => chunks.push(chunk));\n        stream.on('error', error => reject(error));\n        return stream.on('end', () => resolve(Buffer.concat(chunks)));\n      });\n      extractDocument = filename => new Promise(function (resolve, reject) {\n        const document = new oleDoc(filename);\n        document.on('err', error => {\n          return reject(error);\n        });\n        document.on('ready', () => {\n          return resolve(document);\n        });\n        return document.read();\n      });\n      documentStream = (document, stream) => Promise.resolve(document.stream(stream));\n      writeBookmarks = function (buffer, tableBuffer, result) {\n        const fcSttbfBkmk = buffer.readUInt32LE(0x0142);\n        const lcbSttbfBkmk = buffer.readUInt32LE(0x0146);\n        const fcPlcfBkf = buffer.readUInt32LE(0x014a);\n        const lcbPlcfBkf = buffer.readUInt32LE(0x014e);\n        const fcPlcfBkl = buffer.readUInt32LE(0x0152);\n        const lcbPlcfBkl = buffer.readUInt32LE(0x0156);\n        if (lcbSttbfBkmk === 0) {\n          return;\n        }\n        const sttbfBkmk = tableBuffer.slice(fcSttbfBkmk, fcSttbfBkmk + lcbSttbfBkmk);\n        const plcfBkf = tableBuffer.slice(fcPlcfBkf, fcPlcfBkf + lcbPlcfBkf);\n        const plcfBkl = tableBuffer.slice(fcPlcfBkl, fcPlcfBkl + lcbPlcfBkl);\n        const fcExtend = sttbfBkmk.readUInt16LE(0);\n        const cData = sttbfBkmk.readUInt16LE(2); // eslint-disable-line no-unused-vars\n        const cbExtra = sttbfBkmk.readUInt16LE(4); // eslint-disable-line no-unused-vars\n\n        if (fcExtend !== 0xffff) {\n          throw new Error(\"Internal error: unexpected single-byte bookmark data\");\n        }\n        let offset = 6;\n        const index = 0;\n        const bookmarks = {}; // eslint-disable-line no-unused-vars\n\n        while (offset < lcbSttbfBkmk) {\n          let length = sttbfBkmk.readUInt16LE(offset);\n          length = length * 2;\n          const segment = sttbfBkmk.slice(offset + 2, offset + 2 + length);\n          const cpStart = plcfBkf.readUInt32LE(index * 4);\n          const cpEnd = plcfBkl.readUInt32LE(index * 4);\n          result.bookmarks[segment] = {\n            start: cpStart,\n            end: cpEnd\n          };\n          offset = offset + length + 2;\n        }\n      };\n      writePieces = function (buffer, tableBuffer, result) {\n        let flag;\n        let pos = buffer.readUInt32LE(0x01a2);\n        while (true) {\n          // eslint-disable-line no-constant-condition\n          flag = tableBuffer.readUInt8(pos);\n          if (flag !== 1) {\n            break;\n          }\n          pos = pos + 1;\n          const skip = tableBuffer.readUInt16LE(pos);\n          pos = pos + 2 + skip;\n        }\n        flag = tableBuffer.readUInt8(pos);\n        pos = pos + 1;\n        if (flag !== 2) {\n          throw new Error(\"Internal error: ccorrupted Word file\");\n        }\n        const pieceTableSize = tableBuffer.readUInt32LE(pos);\n        pos = pos + 4;\n        const pieces = (pieceTableSize - 4) / 12;\n        let start = 0;\n        let lastPosition = 0;\n        for (let x = 0, end = pieces - 1; x <= end; x++) {\n          const offset = pos + (pieces + 1) * 4 + x * 8 + 2;\n          let filePos = tableBuffer.readUInt32LE(offset);\n          let unicode = false;\n          if ((filePos & 0x40000000) === 0) {\n            unicode = true;\n          } else {\n            filePos = filePos & ~0x40000000;\n            filePos = Math.floor(filePos / 2);\n          }\n          const lStart = tableBuffer.readUInt32LE(pos + x * 4);\n          const lEnd = tableBuffer.readUInt32LE(pos + (x + 1) * 4);\n          const totLength = lEnd - lStart;\n          const piece = {\n            start,\n            totLength,\n            filePos,\n            unicode\n          };\n          getPiece(buffer, piece);\n          piece.length = piece.text.length;\n          piece.position = lastPosition;\n          piece.endPosition = lastPosition + piece.length;\n          result.pieces.push(piece);\n          start = start + (unicode ? Math.floor(totLength / 2) : totLength);\n          lastPosition = lastPosition + piece.length;\n        }\n      };\n      extractWordDocument = (document, buffer) => new Promise(function (resolve, reject) {\n        const magic = buffer.readUInt16LE(0);\n        if (magic !== 0xa5ec) {\n          return reject(new Error(`This does not seem to be a Word document: Invalid magic number: ${magic.toString(16)}`));\n        }\n        const flags = buffer.readUInt16LE(0xA);\n        const table = (flags & 0x0200) !== 0 ? \"1Table\" : \"0Table\";\n        return documentStream(document, table).then(stream => streamBuffer(stream)).then(function (tableBuffer) {\n          const result = new Document();\n          result.boundaries.fcMin = buffer.readUInt32LE(0x0018);\n          result.boundaries.ccpText = buffer.readUInt32LE(0x004c);\n          result.boundaries.ccpFtn = buffer.readUInt32LE(0x0050);\n          result.boundaries.ccpHdd = buffer.readUInt32LE(0x0054);\n          result.boundaries.ccpAtn = buffer.readUInt32LE(0x005c);\n          result.boundaries.ccpEdn = buffer.readUInt32LE(0x0060);\n          writeBookmarks(buffer, tableBuffer, result);\n          writePieces(buffer, tableBuffer, result);\n          return resolve(result);\n        }).catch(error => reject(error));\n      });\n      getPiece = function (buffer, piece) {\n        const pstart = piece.start;\n        const ptotLength = piece.totLength;\n        const pfilePos = piece.filePos;\n        const punicode = piece.unicode;\n        const pend = pstart + ptotLength;\n        const textStart = pfilePos;\n        const textEnd = textStart + (pend - pstart);\n        if (punicode) {\n          return piece.text = addUnicodeText(buffer, textStart, textEnd);\n        } else {\n          return piece.text = addText(buffer, textStart, textEnd);\n        }\n      };\n      addText = function (buffer, textStart, textEnd) {\n        const slice = buffer.slice(textStart, textEnd);\n        return slice.toString('binary');\n      };\n      addUnicodeText = function (buffer, textStart, textEnd) {\n        const slice = buffer.slice(textStart, 2 * textEnd - textStart);\n        const string = slice.toString('ucs2');\n\n        // See the conversion table for FcCompressed structures. Note that these\n        // should not affect positions, as these are characters now, not bytes\n        // for i in [0..string.length]\n        //   if\n\n        return string;\n      };\n    }\n    constructor() {}\n    extract(filename) {\n      return extractDocument(filename).then(document => documentStream(document, 'WordDocument').then(stream => streamBuffer(stream)).then(buffer => extractWordDocument(document, buffer)));\n    }\n  };\n  WordExtractor.initClass();\n  return WordExtractor;\n}();\nmodule.exports = WordExtractor;","map":{"version":3,"names":["Buffer","require","oleDoc","OleCompoundDoc","filters","translations","Document","WordExtractor","streamBuffer","undefined","extractDocument","documentStream","writeBookmarks","writePieces","extractWordDocument","getPiece","addText","addUnicodeText","initClass","stream","Promise","resolve","reject","chunks","on","chunk","push","error","concat","filename","document","read","buffer","tableBuffer","result","fcSttbfBkmk","readUInt32LE","lcbSttbfBkmk","fcPlcfBkf","lcbPlcfBkf","fcPlcfBkl","lcbPlcfBkl","sttbfBkmk","slice","plcfBkf","plcfBkl","fcExtend","readUInt16LE","cData","cbExtra","Error","offset","index","bookmarks","length","segment","cpStart","cpEnd","start","end","flag","pos","readUInt8","skip","pieceTableSize","pieces","lastPosition","x","filePos","unicode","Math","floor","lStart","lEnd","totLength","piece","text","position","endPosition","magic","toString","flags","table","then","boundaries","fcMin","ccpText","ccpFtn","ccpHdd","ccpAtn","ccpEdn","catch","pstart","ptotLength","pfilePos","punicode","pend","textStart","textEnd","string","constructor","extract","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/word-extractor/lib/word.js"],"sourcesContent":["/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nconst { Buffer } =     require('buffer');\n\nconst oleDoc =         require('./ole-doc').OleCompoundDoc;\n\nconst filters =        require('./filters');         // eslint-disable-line no-unused-vars\nconst translations =   require('./translations');    // eslint-disable-line no-unused-vars\n\nconst Document =       require('./document');\n\nvar WordExtractor = (function() {\n  let streamBuffer = undefined;\n  let extractDocument = undefined;\n  let documentStream = undefined;\n  let writeBookmarks = undefined;\n  let writePieces = undefined;\n  let extractWordDocument = undefined;\n  let getPiece = undefined;\n  let addText = undefined;\n  let addUnicodeText = undefined;\n  WordExtractor = class WordExtractor {\n    static initClass() {\n  \n  \n      //# Given an OLE stream, returns all the data in a buffer,\n      //# as a promise.\n      streamBuffer = stream =>\n        new Promise(function(resolve, reject) {\n          const chunks = [];\n          stream.on('data', chunk => chunks.push(chunk));\n          stream.on('error', error => reject(error));\n          return stream.on('end', () => resolve(Buffer.concat(chunks)));\n        })\n      ;\n  \n  \n      extractDocument = filename =>\n        new Promise(function(resolve, reject) {\n          const document = new oleDoc(filename);\n          document.on('err', error => {\n            return reject(error);\n          });\n          document.on('ready', () => {\n            return resolve(document);\n          });\n          return document.read();\n        })\n      ;\n  \n  \n      documentStream = (document, stream) => Promise.resolve(document.stream(stream));\n  \n  \n      writeBookmarks = function(buffer, tableBuffer, result) {\n        const fcSttbfBkmk = buffer.readUInt32LE(0x0142);\n        const lcbSttbfBkmk = buffer.readUInt32LE(0x0146);\n        const fcPlcfBkf = buffer.readUInt32LE(0x014a);\n        const lcbPlcfBkf = buffer.readUInt32LE(0x014e);\n        const fcPlcfBkl = buffer.readUInt32LE(0x0152);\n        const lcbPlcfBkl = buffer.readUInt32LE(0x0156);\n  \n        if (lcbSttbfBkmk === 0) { return; }\n  \n        const sttbfBkmk = tableBuffer.slice(fcSttbfBkmk, fcSttbfBkmk + lcbSttbfBkmk);\n        const plcfBkf = tableBuffer.slice(fcPlcfBkf, fcPlcfBkf + lcbPlcfBkf);\n        const plcfBkl = tableBuffer.slice(fcPlcfBkl, fcPlcfBkl + lcbPlcfBkl);\n  \n        const fcExtend = sttbfBkmk.readUInt16LE(0);\n        const cData = sttbfBkmk.readUInt16LE(2);       // eslint-disable-line no-unused-vars\n        const cbExtra = sttbfBkmk.readUInt16LE(4);     // eslint-disable-line no-unused-vars\n  \n        if (fcExtend !== 0xffff) {\n          throw new Error(\"Internal error: unexpected single-byte bookmark data\");\n        }\n  \n        let offset = 6;\n        const index = 0;\n        const bookmarks = {};                          // eslint-disable-line no-unused-vars\n  \n        while (offset < lcbSttbfBkmk) {\n          let length = sttbfBkmk.readUInt16LE(offset);\n          length = length * 2;\n          const segment = sttbfBkmk.slice(offset + 2, offset + 2 + length);\n          const cpStart = plcfBkf.readUInt32LE(index * 4);\n          const cpEnd = plcfBkl.readUInt32LE(index * 4);\n          result.bookmarks[segment] = {start: cpStart, end: cpEnd};\n          offset = offset + length + 2;\n        }\n      };\n  \n  \n      writePieces = function(buffer, tableBuffer, result) {\n        let flag;\n        let pos = buffer.readUInt32LE(0x01a2);\n  \n        while (true) {                          // eslint-disable-line no-constant-condition\n          flag = tableBuffer.readUInt8(pos);\n          if (flag !== 1) { break; }\n  \n          pos = pos + 1;\n          const skip = tableBuffer.readUInt16LE(pos);\n          pos = pos + 2 + skip;\n        }\n  \n        flag = tableBuffer.readUInt8(pos);\n        pos = pos + 1;\n        if (flag !== 2) {\n          throw new Error(\"Internal error: ccorrupted Word file\");\n        }\n  \n        const pieceTableSize = tableBuffer.readUInt32LE(pos);\n        pos = pos + 4;\n  \n        const pieces = (pieceTableSize - 4) / 12;\n        let start = 0;\n        let lastPosition = 0;\n  \n        for (let x = 0, end = pieces - 1; x <= end; x++) {\n          const offset = pos + ((pieces + 1) * 4) + (x * 8) + 2;\n          let filePos = tableBuffer.readUInt32LE(offset);\n          let unicode = false;\n          if ((filePos & 0x40000000) === 0) {\n            unicode = true;\n          } else {\n            filePos = filePos & ~(0x40000000);\n            filePos = Math.floor(filePos / 2);\n          }\n          const lStart = tableBuffer.readUInt32LE(pos + (x * 4));\n          const lEnd = tableBuffer.readUInt32LE(pos + ((x + 1) * 4));\n          const totLength = lEnd - lStart;\n\n          const piece = {\n            start,\n            totLength,\n            filePos,\n            unicode\n          };\n\n          getPiece(buffer, piece);\n          piece.length = piece.text.length;\n          piece.position = lastPosition;\n          piece.endPosition = lastPosition + piece.length;\n          result.pieces.push(piece);\n\n          start = start + (unicode ? Math.floor(totLength / 2) : totLength);\n          lastPosition = lastPosition + piece.length;\n        }\n      };\n  \n      extractWordDocument = (document, buffer) =>\n        new Promise(function(resolve, reject) {\n          const magic = buffer.readUInt16LE(0);\n          if (magic !== 0xa5ec) {\n            return reject(new Error(`This does not seem to be a Word document: Invalid magic number: ${magic.toString(16)}`));\n          }\n  \n          const flags = buffer.readUInt16LE(0xA);\n  \n          const table = (flags & 0x0200) !== 0 ? \"1Table\" : \"0Table\";\n  \n          return documentStream(document, table)\n            .then(stream => streamBuffer(stream)).then(function(tableBuffer) {\n              const result = new Document();\n              result.boundaries.fcMin = buffer.readUInt32LE(0x0018);\n              result.boundaries.ccpText = buffer.readUInt32LE(0x004c);\n              result.boundaries.ccpFtn = buffer.readUInt32LE(0x0050);\n              result.boundaries.ccpHdd = buffer.readUInt32LE(0x0054);\n              result.boundaries.ccpAtn = buffer.readUInt32LE(0x005c);\n              result.boundaries.ccpEdn = buffer.readUInt32LE(0x0060);\n  \n              writeBookmarks(buffer, tableBuffer, result);\n              writePieces(buffer, tableBuffer, result);\n  \n              return resolve(result);}).catch(error => reject(error));\n        })\n      ;\n  \n  \n      getPiece = function(buffer, piece) {\n        const pstart = piece.start;\n        const ptotLength = piece.totLength;\n        const pfilePos = piece.filePos;\n        const punicode = piece.unicode;\n  \n        const pend = pstart + ptotLength;\n        const textStart = pfilePos;\n        const textEnd = textStart + (pend - pstart);\n  \n        if (punicode) {\n          return piece.text = addUnicodeText(buffer, textStart, textEnd);\n        } else {\n          return piece.text = addText(buffer, textStart, textEnd);\n        }\n      };\n  \n  \n      addText = function(buffer, textStart, textEnd) {\n        const slice = buffer.slice(textStart, textEnd);\n        return slice.toString('binary');\n      };\n  \n      addUnicodeText = function(buffer, textStart, textEnd) {\n        const slice = buffer.slice(textStart, (2*textEnd) - textStart);\n        const string = slice.toString('ucs2');\n  \n        // See the conversion table for FcCompressed structures. Note that these\n        // should not affect positions, as these are characters now, not bytes\n        // for i in [0..string.length]\n        //   if\n  \n        return string;\n      };\n    }\n\n    constructor() {}\n\n\n    extract(filename) {\n      return extractDocument(filename)\n        .then(document =>\n          documentStream(document, 'WordDocument')\n            .then(stream => streamBuffer(stream)).then(buffer => extractWordDocument(document, buffer))\n        );\n    }\n  };\n  WordExtractor.initClass();\n  return WordExtractor;\n})();\n\n\nmodule.exports = WordExtractor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}