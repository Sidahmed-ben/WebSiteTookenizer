{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar Stream = require('stream').Stream,\n  es = exports,\n  through = require('through'),\n  from = require('from'),\n  duplex = require('duplexer'),\n  map = require('map-stream'),\n  pause = require('pause-stream'),\n  split = require('split'),\n  pipeline = require('stream-combiner'),\n  immediately = global.setImmediate || process.nextTick;\nes.Stream = Stream; //re-export Stream from core\nes.through = through;\nes.from = from;\nes.duplex = duplex;\nes.map = map;\nes.pause = pause;\nes.split = split;\nes.pipeline = es.connect = es.pipe = pipeline;\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat =\n//actually this should be called concat\nes.merge = function /*streams...*/\n() {\n  var toMerge = [].slice.call(arguments);\n  if (toMerge.length === 1 && toMerge[0] instanceof Array) {\n    toMerge = toMerge[0]; //handle array as arguments object\n  }\n\n  var stream = new Stream();\n  stream.setMaxListeners(0); // allow adding more than 11 streams\n  var endCount = 0;\n  stream.writable = stream.readable = true;\n  if (toMerge.length) {\n    toMerge.forEach(function (e) {\n      e.pipe(stream, {\n        end: false\n      });\n      var ended = false;\n      e.on('end', function () {\n        if (ended) return;\n        ended = true;\n        endCount++;\n        if (endCount == toMerge.length) stream.emit('end');\n      });\n    });\n  } else {\n    process.nextTick(function () {\n      stream.emit('end');\n    });\n  }\n  stream.write = function (data) {\n    this.emit('data', data);\n  };\n  stream.destroy = function () {\n    toMerge.forEach(function (e) {\n      if (e.destroy) e.destroy();\n    });\n  };\n  return stream;\n};\n\n// writable stream, collects all events into an array\n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done) throw new Error('function writeArray (done): done must be function');\n  var a = new Stream(),\n    array = [],\n    isDone = false;\n  a.write = function (l) {\n    array.push(l);\n  };\n  a.end = function () {\n    isDone = true;\n    done(null, array);\n  };\n  a.writable = true;\n  a.readable = false;\n  a.destroy = function () {\n    a.writable = a.readable = false;\n    if (isDone) return;\n    done(new Error('destroyed before end'), array);\n  };\n  return a;\n};\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream(),\n    i = 0,\n    paused = false,\n    ended = false;\n  stream.readable = true;\n  stream.writable = false;\n  if (!Array.isArray(array)) throw new Error('event-stream.read expects an array');\n  stream.resume = function () {\n    if (ended) return;\n    paused = false;\n    var l = array.length;\n    while (i < l && !paused && !ended) {\n      stream.emit('data', array[i++]);\n    }\n    if (i == l && !ended) ended = true, stream.readable = false, stream.emit('end');\n  };\n  process.nextTick(stream.resume);\n  stream.pause = function () {\n    paused = true;\n  };\n  stream.destroy = function () {\n    ended = true;\n    stream.emit('close');\n  };\n  return stream;\n};\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\nes.readable = function (func, continueOnError) {\n  var stream = new Stream(),\n    i = 0,\n    paused = false,\n    ended = false,\n    reading = false;\n  stream.readable = true;\n  stream.writable = false;\n  if ('function' !== typeof func) throw new Error('event-stream.readable expects async function');\n  stream.on('end', function () {\n    ended = true;\n  });\n  function get(err, data) {\n    if (err) {\n      stream.emit('error', err);\n      if (!continueOnError) stream.emit('end');\n    } else if (arguments.length > 1) stream.emit('data', data);\n    immediately(function () {\n      if (ended || paused || reading) return;\n      try {\n        reading = true;\n        func.call(stream, i++, function () {\n          reading = false;\n          get.apply(null, arguments);\n        });\n      } catch (err) {\n        stream.emit('error', err);\n      }\n    });\n  }\n  stream.resume = function () {\n    paused = false;\n    get();\n  };\n  process.nextTick(get);\n  stream.pause = function () {\n    paused = true;\n  };\n  stream.destroy = function () {\n    stream.emit('end');\n    stream.emit('close');\n    ended = true;\n  };\n  return stream;\n};\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) {\n  return es.through(function write(data) {\n    var mappedData;\n    try {\n      mappedData = sync(data);\n    } catch (err) {\n      return this.emit('error', err);\n    }\n    if (mappedData !== undefined) this.emit('data', mappedData);\n  });\n};\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments);\n    if (name) console.error(name, data);else console.error(data);\n    this.emit('data', data);\n  });\n};\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n  return es.duplex(child.stdin, child.stdout);\n};\n\n//\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\nes.parse = function (options) {\n  var emitError = !!(options ? options.error : false);\n  return es.through(function (data) {\n    var obj;\n    try {\n      if (data)\n        //ignore empty lines\n        obj = JSON.parse(data.toString());\n    } catch (err) {\n      if (emitError) return this.emit('error', err);\n      return console.error(err, 'attempting to parse:', data);\n    }\n    //ignore lines that where only whitespace.\n    if (obj !== undefined) this.emit('data', obj);\n  });\n};\n//\n// stringify\n//\n\nes.stringify = function () {\n  var Buffer = require('buffer').Buffer;\n  return es.mapSync(function (e) {\n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n';\n  });\n};\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join().\n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to));\n};\n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n//\n\nes.join = function (str) {\n  //legacy api\n  if ('function' === typeof str) return es.wait(str);\n  var first = true;\n  return es.through(function (data) {\n    if (!first) this.emit('data', str);\n    first = false;\n    this.emit('data', data);\n    return true;\n  });\n};\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var arr = [];\n  return es.through(function (data) {\n    arr.push(data);\n  }, function () {\n    var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join('');\n    this.emit('data', body);\n    this.emit('end');\n    if (callback) callback(null, body);\n  });\n};\nes.pipeable = function () {\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated');\n};","map":{"version":3,"names":["Stream","require","es","exports","through","from","duplex","map","pause","split","pipeline","immediately","global","setImmediate","process","nextTick","connect","pipe","concat","merge","toMerge","slice","call","arguments","length","Array","stream","setMaxListeners","endCount","writable","readable","forEach","e","end","ended","on","emit","write","data","destroy","writeArray","done","Error","a","array","isDone","l","push","readArray","i","paused","isArray","resume","func","continueOnError","reading","get","err","apply","mapSync","sync","mappedData","undefined","log","name","args","console","error","child","stdin","stdout","parse","options","emitError","obj","JSON","toString","stringify","Buffer","isBuffer","replace","to","join","str","wait","first","callback","arr","body","pipeable"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/event-stream/index.js"],"sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar Stream = require('stream').Stream\n  , es = exports\n  , through = require('through')\n  , from = require('from')\n  , duplex = require('duplexer')\n  , map = require('map-stream')\n  , pause = require('pause-stream')\n  , split = require('split')\n  , pipeline = require('stream-combiner')\n  , immediately = global.setImmediate || process.nextTick;\n\nes.Stream = Stream //re-export Stream from core\nes.through = through\nes.from = from\nes.duplex = duplex\nes.map = map\nes.pause = pause\nes.split = split\nes.pipeline = es.connect = es.pipe = pipeline\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  if (toMerge.length === 1 && (toMerge[0] instanceof Array)) {\n    toMerge = toMerge[0] //handle array as arguments object\n  }\n  var stream = new Stream()\n  stream.setMaxListeners(0) // allow adding more than 11 streams\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  if (toMerge.length) {\n    toMerge.forEach(function (e) {\n      e.pipe(stream, {end: false})\n      var ended = false\n      e.on('end', function () {\n        if(ended) return\n        ended = true\n        endCount ++\n        if(endCount == toMerge.length)\n          stream.emit('end')\n      })\n    })\n  } else {\n    process.nextTick(function () {\n      stream.emit('end')\n    })\n  }\n  \n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n  stream.destroy = function () {\n    toMerge.forEach(function (e) {\n      if(e.destroy) e.destroy()\n    })\n  }\n  return stream\n}\n\n\n// writable stream, collects all events into an array\n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = [], isDone = false\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    isDone = true\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  a.destroy = function () {\n    a.writable = a.readable = false\n    if(isDone) return\n    done(new Error('destroyed before end'), array)\n  }\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n\n  stream.readable = true\n  stream.writable = false\n\n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n\n  stream.resume = function () {\n    if(ended) return\n    paused = false\n    var l = array.length\n    while(i < l && !paused && !ended) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l && !ended)\n      ended = true, stream.readable = false, stream.emit('end')\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    ended = true\n    stream.emit('close')\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\nes.readable =\nfunction (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true\n  stream.writable = false\n\n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n\n  stream.on('end', function () { ended = true })\n\n  function get (err, data) {\n\n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    immediately(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)\n      }\n    })\n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('end')\n    stream.emit('close')\n    ended = true\n  }\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) {\n  return es.through(function write(data) {\n    var mappedData\n    try {\n      mappedData = sync(data)\n    } catch (err) {\n      return this.emit('error', err)\n    }\n    if (mappedData !== undefined)\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\nes.parse = function (options) {\n  var emitError = !!(options ? options.error : false)\n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      if (emitError)\n        return this.emit('error', err)\n      return console.error(err, 'attempting to parse:', data)\n    }\n    //ignore lines that where only whitespace.\n    if(obj !== undefined)\n      this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () {\n  var Buffer = require('buffer').Buffer\n  return es.mapSync(function (e){\n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n'\n  })\n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join().\n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to))\n}\n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n//\n\nes.join = function (str) {\n\n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var first = true\n  return es.through(function (data) {\n    if(!first)\n      this.emit('data', str)\n    first = false\n    this.emit('data', data)\n    return true\n  })\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var arr = []\n  return es.through(function (data) { arr.push(data) },\n    function () {\n      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)\n        : arr.join('')\n      this.emit('data', body)\n      this.emit('end')\n      if(callback) callback(null, body)\n    })\n}\n\nes.pipeable = function () {\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}