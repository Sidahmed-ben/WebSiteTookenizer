{"ast":null,"code":"const fs = require('fs');\nconst StreamZip = require('node-stream-zip');\nconst XLSX = require('xlsx');\nconst pdf = require('pdf-parse');\nvar WordExtractor = require('word-extractor');\n\n// extract text from office books as doc and docx\nextract = filePath => {\n  return new Promise((resolve, reject) => {\n    open(filePath).then((res, err) => {\n      if (err) {\n        reject(err);\n      }\n      let body = '';\n      let components = res.toString().split('<w:t');\n      for (let i = 0; i < components.length; i++) {\n        let tags = components[i].split('>');\n        let content = tags[1].replace(/<.*$/, '');\n        body += content;\n      }\n      resolve(body);\n    });\n  });\n};\n\n// stream\nopen = filePath => {\n  return new Promise((resolve, reject) => {\n    const zip = new StreamZip({\n      file: filePath,\n      storeEntries: true\n    });\n    zip.on('ready', () => {\n      let chunks = [];\n      let content = '';\n      zip.stream('word/document.xml', (err, stream) => {\n        if (err) {\n          reject(err);\n        }\n        stream.on('data', chunk => {\n          chunks.push(chunk);\n        });\n        stream.on('end', () => {\n          content = Buffer.concat(chunks);\n          zip.close();\n          resolve(content.toString());\n        });\n      });\n    });\n  });\n};\n\n// get the file extension based on the file path\ngetFileExtension = filename => {\n  if (filename.length == 0) return '';\n  let dot = filename.lastIndexOf('.');\n  if (dot == -1) return '';\n  const extension = filename.substr(dot, filename.length);\n  return extension;\n};\n\n// read the file and extract text\nexports.getText = async filePath => {\n  let fileContent = '';\n  let data = fs.readFileSync(filePath);\n  const fileExtension = getFileExtension(filePath);\n  switch (fileExtension) {\n    // read pdf\n    case '.pdf':\n      fileContent = await (await pdf(data)).text;\n      break;\n\n    // read docs\n\n    case '.docx':\n      fileContent = await extract(filePath);\n      break;\n    case '.doc':\n      var extractor = new WordExtractor();\n      var extracted = await extractor.extract(filePath);\n      fileContent = extracted.getBody();\n      break;\n\n    // read excel books\n    case '.xlsx':\n    case '.xls':\n      let result = {};\n      data = new Uint8Array(data);\n      let workbook = XLSX.read(data, {\n        type: 'array'\n      });\n      workbook.SheetNames.forEach(function (sheetName) {\n        let roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {\n          header: 1\n        });\n        if (roa.length) result[sheetName] = roa;\n      });\n      fileContent = JSON.stringify(result);\n      break;\n\n    // read text and csv\n    case '.txt':\n    case '.csv':\n      fileContent = data.toString();\n      break;\n\n    // default case\n    default:\n      throw new Error('unknown extension found!');\n  }\n  // console.log(`This is file content ==> ${fileContent}`);\n  return fileContent;\n};","map":{"version":3,"names":["fs","require","StreamZip","XLSX","pdf","WordExtractor","extract","filePath","Promise","resolve","reject","open","then","res","err","body","components","toString","split","i","length","tags","content","replace","zip","file","storeEntries","on","chunks","stream","chunk","push","Buffer","concat","close","getFileExtension","filename","dot","lastIndexOf","extension","substr","exports","getText","fileContent","data","readFileSync","fileExtension","text","extractor","extracted","getBody","result","Uint8Array","workbook","read","type","SheetNames","forEach","sheetName","roa","utils","sheet_to_json","Sheets","header","JSON","stringify","Error"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/front/node_modules/any-text/index.js"],"sourcesContent":["const fs = require('fs');\nconst StreamZip = require('node-stream-zip');\nconst XLSX = require('xlsx');\nconst pdf = require('pdf-parse');\nvar WordExtractor = require('word-extractor');\n\n// extract text from office books as doc and docx\nextract = (filePath) => {\n  return new Promise((resolve, reject) => {\n    open(filePath).then((res, err) => {\n      if (err) {\n        reject(err);\n      }\n      let body = '';\n      let components = res.toString().split('<w:t');\n      for (let i = 0; i < components.length; i++) {\n        let tags = components[i].split('>');\n        let content = tags[1].replace(/<.*$/, '');\n        body += content;\n      }\n      resolve(body);\n    });\n  });\n};\n\n// stream\nopen = (filePath) => {\n  return new Promise((resolve, reject) => {\n    const zip = new StreamZip({\n      file: filePath,\n      storeEntries: true,\n    });\n    zip.on('ready', () => {\n      let chunks = [];\n      let content = '';\n      zip.stream('word/document.xml', (err, stream) => {\n        if (err) {\n          reject(err);\n        }\n        stream.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n        stream.on('end', () => {\n          content = Buffer.concat(chunks);\n          zip.close();\n          resolve(content.toString());\n        });\n      });\n    });\n  });\n};\n\n// get the file extension based on the file path\ngetFileExtension = (filename) => {\n  if (filename.length == 0) return '';\n  let dot = filename.lastIndexOf('.');\n  if (dot == -1) return '';\n  const extension = filename.substr(dot, filename.length);\n  return extension;\n};\n\n// read the file and extract text\nexports.getText = async (filePath) => {\n  let fileContent = '';\n\n  let data = fs.readFileSync(filePath);\n  const fileExtension = getFileExtension(filePath);\n\n  switch (fileExtension) {\n    // read pdf\n    case '.pdf':\n      fileContent = await (await pdf(data)).text;\n      break;\n\n    // read docs\n\n    case '.docx':\n      fileContent = await extract(filePath);\n      break;\n\n    case '.doc':\n      var extractor = new WordExtractor();\n      var extracted = await extractor.extract(filePath);\n      fileContent = extracted.getBody();\n      break;\n\n    // read excel books\n    case '.xlsx':\n    case '.xls':\n      let result = {};\n      data = new Uint8Array(data);\n      let workbook = XLSX.read(data, {\n        type: 'array',\n      });\n      workbook.SheetNames.forEach(function (sheetName) {\n        let roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {\n          header: 1,\n        });\n        if (roa.length) result[sheetName] = roa;\n      });\n      fileContent = JSON.stringify(result);\n      break;\n\n    // read text and csv\n    case '.txt':\n    case '.csv':\n      fileContent = data.toString();\n      break;\n\n    // default case\n    default:\n      throw new Error('unknown extension found!');\n  }\n  // console.log(`This is file content ==> ${fileContent}`);\n  return fileContent;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}