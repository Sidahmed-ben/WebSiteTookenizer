{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst {\n  Tokenizer\n} = require('@nlpjs/core');\nconst aspects = require('./thai-aspects.json');\nclass TokenizerTh extends Tokenizer {\n  constructor(container, shouldTokenize) {\n    super(container, shouldTokenize);\n    this.name = 'tokenizer-th';\n  }\n  addToTree(aspect) {\n    let node = this.dict;\n    for (let i = 0; i < aspect.length; i += 1) {\n      const current = aspect[i];\n      if (!node[current]) {\n        node[current] = {};\n      }\n      node = node[current];\n    }\n    node.isLeaf = true;\n  }\n  buildDictionary() {\n    this.dict = {};\n    for (let i = 0; i < aspects.length; i += 1) {\n      this.addToTree(aspects[i]);\n    }\n  }\n  findCollisions(token, tokens) {\n    const result = [];\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      if (!current.isDiscarded && current.start !== token.start || current.length !== token.length) {\n        if (current.start <= token.end && current.end >= token.start) {\n          result.push(current);\n        }\n      }\n    }\n    return result;\n  }\n  perfectCompose(token, collisions) {\n    for (let i = 0; i < collisions.length; i += 1) {\n      const a = collisions[i];\n      if (a.start <= token.start) {\n        for (let j = 1; j < collisions.length; j += 1) {\n          const b = collisions[j];\n          if (b.start === a.end + 1 && b.end === token.end) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  isLate(token, collisions) {\n    let open = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    for (let i = 0; i < collisions.length; i += 1) {\n      if (!open && token.start > collisions[i].start && token.end < collisions[i].end) {\n        return true;\n      }\n      if (open && token.start >= collisions[i].start && token.end <= collisions[i].end) {\n        return true;\n      }\n    }\n    return false;\n  }\n  fullSure(tokens) {\n    for (let i = 0; i < tokens.length; i += 1) {\n      if (!tokens[i].isSure) {\n        return false;\n      }\n    }\n    return true;\n  }\n  reduceEdges(srcTokens) {\n    let tokens = srcTokens;\n    let lastLength = 0;\n    while (lastLength !== tokens.length && !this.fullSure(tokens)) {\n      lastLength = tokens.length;\n      for (let open = 0; open <= 1; open += 1) {\n        for (let i = 0; i < tokens.length; i += 1) {\n          const current = tokens[i];\n          const collisions = this.findCollisions(current, tokens);\n          if (collisions.length === 0) {\n            current.isSure = true;\n            current.isDiscarded = false;\n          } else if (this.perfectCompose(current, collisions)) {\n            current.isDiscarded = true;\n          } else if (this.isLate(current, collisions, open === 1)) {\n            current.isDiscarded = true;\n          }\n        }\n        tokens = tokens.filter(x => !x.isDiscarded);\n      }\n    }\n    return tokens;\n  }\n  innerTokenize(str) {\n    if (!this.dict) {\n      this.buildDictionary();\n    }\n    const potentialTokens = [];\n    let currentChains = [];\n    for (let i = 0; i < str.length; i += 1) {\n      const chr = str[i];\n      if (this.dict[chr]) {\n        currentChains.push({\n          node: this.dict,\n          value: ''\n        });\n      }\n      for (let j = 0; j < currentChains.length; j += 1) {\n        const chain = currentChains[j];\n        const nextNode = chain.node[chr];\n        if (nextNode) {\n          currentChains[j] = {\n            node: nextNode,\n            value: chain.value + chr\n          };\n        } else {\n          currentChains[j] = undefined;\n        }\n        if (nextNode && nextNode.isLeaf) {\n          potentialTokens.push({\n            start: i - currentChains[j].value.length + 1,\n            length: currentChains[j].value.length,\n            end: i,\n            value: currentChains[j].value\n          });\n        }\n      }\n      currentChains = currentChains.filter(x => x);\n    }\n    const edges = this.reduceEdges(potentialTokens);\n    let index = 0;\n    const result = [];\n    for (let i = 0; i < edges.length; i += 1) {\n      const current = edges[i];\n      if (current.start > index) {\n        result.push(...str.slice(index, current.start).split(/[\\s,.!?;:([\\]'\"¡¿)/]+/));\n      }\n      result.push(current.value);\n      index = current.end + 1;\n    }\n    if (index < str.length) {\n      result.push(...str.slice(index).split(/[\\s,.!?;:([\\]'\"¡¿)/]+/));\n    }\n    return result;\n  }\n}\nmodule.exports = TokenizerTh;","map":{"version":3,"names":["Tokenizer","require","aspects","TokenizerTh","constructor","container","shouldTokenize","name","addToTree","aspect","node","dict","i","length","current","isLeaf","buildDictionary","findCollisions","token","tokens","result","isDiscarded","start","end","push","perfectCompose","collisions","a","j","b","isLate","open","arguments","undefined","fullSure","isSure","reduceEdges","srcTokens","lastLength","filter","x","innerTokenize","str","potentialTokens","currentChains","chr","value","chain","nextNode","edges","index","slice","split","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/lang-th/src/tokenizer-th.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst { Tokenizer } = require('@nlpjs/core');\nconst aspects = require('./thai-aspects.json');\n\nclass TokenizerTh extends Tokenizer {\n  constructor(container, shouldTokenize) {\n    super(container, shouldTokenize);\n    this.name = 'tokenizer-th';\n  }\n\n  addToTree(aspect) {\n    let node = this.dict;\n    for (let i = 0; i < aspect.length; i += 1) {\n      const current = aspect[i];\n      if (!node[current]) {\n        node[current] = {};\n      }\n      node = node[current];\n    }\n    node.isLeaf = true;\n  }\n\n  buildDictionary() {\n    this.dict = {};\n    for (let i = 0; i < aspects.length; i += 1) {\n      this.addToTree(aspects[i]);\n    }\n  }\n\n  findCollisions(token, tokens) {\n    const result = [];\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      if (\n        (!current.isDiscarded && current.start !== token.start) ||\n        current.length !== token.length\n      ) {\n        if (current.start <= token.end && current.end >= token.start) {\n          result.push(current);\n        }\n      }\n    }\n    return result;\n  }\n\n  perfectCompose(token, collisions) {\n    for (let i = 0; i < collisions.length; i += 1) {\n      const a = collisions[i];\n      if (a.start <= token.start) {\n        for (let j = 1; j < collisions.length; j += 1) {\n          const b = collisions[j];\n          if (b.start === a.end + 1 && b.end === token.end) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  isLate(token, collisions, open = false) {\n    for (let i = 0; i < collisions.length; i += 1) {\n      if (\n        !open &&\n        token.start > collisions[i].start &&\n        token.end < collisions[i].end\n      ) {\n        return true;\n      }\n      if (\n        open &&\n        token.start >= collisions[i].start &&\n        token.end <= collisions[i].end\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  fullSure(tokens) {\n    for (let i = 0; i < tokens.length; i += 1) {\n      if (!tokens[i].isSure) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  reduceEdges(srcTokens) {\n    let tokens = srcTokens;\n    let lastLength = 0;\n    while (lastLength !== tokens.length && !this.fullSure(tokens)) {\n      lastLength = tokens.length;\n      for (let open = 0; open <= 1; open += 1) {\n        for (let i = 0; i < tokens.length; i += 1) {\n          const current = tokens[i];\n          const collisions = this.findCollisions(current, tokens);\n          if (collisions.length === 0) {\n            current.isSure = true;\n            current.isDiscarded = false;\n          } else if (this.perfectCompose(current, collisions)) {\n            current.isDiscarded = true;\n          } else if (this.isLate(current, collisions, open === 1)) {\n            current.isDiscarded = true;\n          }\n        }\n        tokens = tokens.filter((x) => !x.isDiscarded);\n      }\n    }\n    return tokens;\n  }\n\n  innerTokenize(str) {\n    if (!this.dict) {\n      this.buildDictionary();\n    }\n    const potentialTokens = [];\n    let currentChains = [];\n    for (let i = 0; i < str.length; i += 1) {\n      const chr = str[i];\n      if (this.dict[chr]) {\n        currentChains.push({ node: this.dict, value: '' });\n      }\n      for (let j = 0; j < currentChains.length; j += 1) {\n        const chain = currentChains[j];\n        const nextNode = chain.node[chr];\n        if (nextNode) {\n          currentChains[j] = { node: nextNode, value: chain.value + chr };\n        } else {\n          currentChains[j] = undefined;\n        }\n        if (nextNode && nextNode.isLeaf) {\n          potentialTokens.push({\n            start: i - currentChains[j].value.length + 1,\n            length: currentChains[j].value.length,\n            end: i,\n            value: currentChains[j].value,\n          });\n        }\n      }\n      currentChains = currentChains.filter((x) => x);\n    }\n    const edges = this.reduceEdges(potentialTokens);\n    let index = 0;\n    const result = [];\n    for (let i = 0; i < edges.length; i += 1) {\n      const current = edges[i];\n      if (current.start > index) {\n        result.push(\n          ...str.slice(index, current.start).split(/[\\s,.!?;:([\\]'\"¡¿)/]+/)\n        );\n      }\n      result.push(current.value);\n      index = current.end + 1;\n    }\n    if (index < str.length) {\n      result.push(...str.slice(index).split(/[\\s,.!?;:([\\]'\"¡¿)/]+/));\n    }\n    return result;\n  }\n}\n\nmodule.exports = TokenizerTh;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}