{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst {\n  defaultContainer\n} = require('@nlpjs/core');\nconst {\n  Language\n} = require('@nlpjs/language-min');\nconst {\n  similarity\n} = require('@nlpjs/similarity');\nconst reduceEdges = require('./reduce-edges');\nclass ExtractorEnum {\n  constructor() {\n    let container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultContainer;\n    this.container = container.container || container;\n    this.name = 'extract-enum';\n  }\n  getScripts(str) {\n    const result = [];\n    const chars = str.split('');\n    for (let i = 0; i < chars.length; i += 1) {\n      result.push(Language.getTopScript(chars[i]));\n    }\n    return result;\n  }\n  isAlphanumeric(c) {\n    return /[\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]/.test(c) && c !== '_';\n  }\n  getWordPositions(str) {\n    const scripts = this.getScripts(str);\n    let atWhiteSpace = true;\n    let lastIndex = 0;\n    let currentIndex = 0;\n    const strlen = str.length;\n    const result = [];\n    while (currentIndex < strlen) {\n      if (this.isAlphanumeric(str.charAt(currentIndex))) {\n        if (atWhiteSpace) {\n          if (scripts[currentIndex][0] === 'cmn') {\n            result.push({\n              start: currentIndex,\n              end: currentIndex,\n              len: 1\n            });\n            lastIndex = currentIndex;\n          } else {\n            lastIndex = currentIndex;\n            atWhiteSpace = false;\n          }\n        }\n      } else if (!atWhiteSpace) {\n        result.push({\n          start: lastIndex,\n          end: currentIndex - 1,\n          len: currentIndex - lastIndex\n        });\n        atWhiteSpace = true;\n      }\n      currentIndex += 1;\n    }\n    if (!atWhiteSpace) {\n      result.push({\n        start: lastIndex,\n        end: currentIndex - 1,\n        len: currentIndex - lastIndex\n      });\n    }\n    return result;\n  }\n  getBestSubstring(str1, str2, words1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    if (str1len <= str2len) {\n      const result = {\n        start: 0,\n        end: str1len - 1,\n        len: str1len,\n        levenshtein: similarity(str1, str2, true)\n      };\n      result.accuracy = (str2len - result.levenshtein) / str2len;\n      return result;\n    }\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    const best = {\n      start: 0,\n      end: 0,\n      len: 0,\n      levenshtein: undefined,\n      accuracy: 0\n    };\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        const levenshtein = similarity(str3, str2, true);\n        if (best.levenshtein === undefined || levenshtein < best.levenshtein) {\n          best.levenshtein = levenshtein;\n          best.start = wordPositions[i].start;\n          best.end = wordPositions[j].end;\n          best.len = best.end - best.start + 1;\n        }\n      }\n    }\n    best.accuracy = (str2len - best.levenshtein) / str2len;\n    return best;\n  }\n  getBestSubstringList(str1, str2, words1) {\n    let threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const str1len = str1.length;\n    const str2len = str2.length;\n    const result = [];\n    if (str1len <= str2len) {\n      const levenshtein = similarity(str1, str2, true);\n      const accuracy = (str2len - levenshtein) / str2len;\n      if (accuracy >= threshold) {\n        result.push({\n          start: 0,\n          end: str1len - 1,\n          len: str1len,\n          levenshtein,\n          accuracy\n        });\n      }\n      return result;\n    }\n    const maxLevenshtein = str2len * (1 - threshold);\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        const levenshtein = similarity(str3, str2, true);\n        const accuracy = (str2len - levenshtein) / str2len;\n        if (accuracy >= threshold) {\n          result.push({\n            start: wordPositions[i].start,\n            end: wordPositions[j].end,\n            len: wordPositions[j].end - wordPositions[i].start + 1,\n            levenshtein,\n            accuracy\n          });\n        }\n        if (str3.length - wordPositions[0].len >= str2.length + maxLevenshtein) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n  normalize(str) {\n    return str.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n  }\n  buildRuleDict(rule) {\n    const dict = {};\n    const inverse = {};\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      for (let j = 0; j < current.texts.length; j += 1) {\n        const source = current.texts[j];\n        const key = this.normalize(current.texts[j]);\n        if (!dict[key]) {\n          dict[key] = [];\n        }\n        dict[key].push(current);\n        inverse[key] = source;\n      }\n    }\n    rule.dict = dict;\n    rule.inverseDict = inverse;\n  }\n  getBestExact(srcText, words, rule) {\n    const text = this.normalize(srcText);\n    const wordPositions = words || this.getWordPositions(text);\n    const wordPositionsLen = wordPositions.length;\n    const result = [];\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str = text.substring(wordPositions[i].start, wordPositions[j].end + 1);\n        if (rule.dict[str]) {\n          const subrule = rule.dict[str];\n          for (let k = 0; k < subrule.length; k += 1) {\n            result.push({\n              accuracy: 1,\n              start: wordPositions[i].start,\n              end: wordPositions[j].end,\n              len: wordPositions[j].end - wordPositions[i].start + 1,\n              levenshtein: 0,\n              entity: rule.name,\n              type: rule.type,\n              option: subrule[k].option,\n              sourceText: rule.inverseDict[str],\n              utteranceText: srcText.substring(wordPositions[i].start, wordPositions[j].end + 1)\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n  extractFromRule(text, rule, words, threshold) {\n    if (rule.type === 'enum') {\n      const edges = [];\n      if (threshold >= 1) {\n        if (!rule.dict) {\n          this.buildRuleDict(rule);\n        }\n        const newEdges = this.getBestExact(text, words, rule);\n        for (let i = 0; i < newEdges.length; i += 1) {\n          edges.push(newEdges[i]);\n        }\n      } else {\n        for (let i = 0; i < rule.rules.length; i += 1) {\n          const current = rule.rules[i];\n          if (current && current.option && Array.isArray(current.texts)) {\n            for (let j = 0; j < current.texts.length; j += 1) {\n              const newEdges = this.getBestSubstringList(text, current.texts[j], words, current.threshold || threshold);\n              for (let k = 0; k < newEdges.length; k += 1) {\n                edges.push({\n                  ...newEdges[k],\n                  entity: rule.name,\n                  type: rule.type,\n                  option: rule.rules[i].option,\n                  sourceText: current.texts[j],\n                  utteranceText: text.substring(newEdges[k].start, newEdges[k].end + 1)\n                });\n              }\n            }\n          }\n        }\n      }\n      return edges;\n    }\n    return [];\n  }\n  extract(srcInput) {\n    const input = srcInput;\n    const wordPositions = this.getWordPositions(input.text || input.utterance);\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(input.text || input.utterance, rules[i], wordPositions, input.threshold || 0.8);\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-enum-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\nmodule.exports = ExtractorEnum;","map":{"version":3,"names":["defaultContainer","require","Language","similarity","reduceEdges","ExtractorEnum","constructor","container","arguments","length","undefined","name","getScripts","str","result","chars","split","i","push","getTopScript","isAlphanumeric","c","test","getWordPositions","scripts","atWhiteSpace","lastIndex","currentIndex","strlen","charAt","start","end","len","getBestSubstring","str1","str2","words1","str1len","str2len","levenshtein","accuracy","wordPositions","wordPositionsLen","best","j","str3","substring","getBestSubstringList","threshold","maxLevenshtein","getRules","input","allRules","nerRules","normalize","replace","toLowerCase","buildRuleDict","rule","dict","inverse","rules","current","texts","source","key","inverseDict","getBestExact","srcText","words","text","subrule","k","entity","type","option","sourceText","utteranceText","extractFromRule","edges","newEdges","Array","isArray","extract","srcInput","utterance","sort","a","b","run","locale","extractor","get","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/ner/src/extractor-enum.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst { defaultContainer } = require('@nlpjs/core');\nconst { Language } = require('@nlpjs/language-min');\nconst { similarity } = require('@nlpjs/similarity');\nconst reduceEdges = require('./reduce-edges');\n\nclass ExtractorEnum {\n  constructor(container = defaultContainer) {\n    this.container = container.container || container;\n    this.name = 'extract-enum';\n  }\n\n  getScripts(str) {\n    const result = [];\n    const chars = str.split('');\n    for (let i = 0; i < chars.length; i += 1) {\n      result.push(Language.getTopScript(chars[i]));\n    }\n    return result;\n  }\n\n  isAlphanumeric(c) {\n    return /[\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]/.test(c) && c !== '_';\n  }\n\n  getWordPositions(str) {\n    const scripts = this.getScripts(str);\n    let atWhiteSpace = true;\n    let lastIndex = 0;\n    let currentIndex = 0;\n    const strlen = str.length;\n    const result = [];\n    while (currentIndex < strlen) {\n      if (this.isAlphanumeric(str.charAt(currentIndex))) {\n        if (atWhiteSpace) {\n          if (scripts[currentIndex][0] === 'cmn') {\n            result.push({\n              start: currentIndex,\n              end: currentIndex,\n              len: 1,\n            });\n            lastIndex = currentIndex;\n          } else {\n            lastIndex = currentIndex;\n            atWhiteSpace = false;\n          }\n        }\n      } else if (!atWhiteSpace) {\n        result.push({\n          start: lastIndex,\n          end: currentIndex - 1,\n          len: currentIndex - lastIndex,\n        });\n        atWhiteSpace = true;\n      }\n      currentIndex += 1;\n    }\n    if (!atWhiteSpace) {\n      result.push({\n        start: lastIndex,\n        end: currentIndex - 1,\n        len: currentIndex - lastIndex,\n      });\n    }\n    return result;\n  }\n\n  getBestSubstring(str1, str2, words1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    if (str1len <= str2len) {\n      const result = {\n        start: 0,\n        end: str1len - 1,\n        len: str1len,\n        levenshtein: similarity(str1, str2, true),\n      };\n      result.accuracy = (str2len - result.levenshtein) / str2len;\n      return result;\n    }\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    const best = {\n      start: 0,\n      end: 0,\n      len: 0,\n      levenshtein: undefined,\n      accuracy: 0,\n    };\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        const levenshtein = similarity(str3, str2, true);\n        if (best.levenshtein === undefined || levenshtein < best.levenshtein) {\n          best.levenshtein = levenshtein;\n          best.start = wordPositions[i].start;\n          best.end = wordPositions[j].end;\n          best.len = best.end - best.start + 1;\n        }\n      }\n    }\n    best.accuracy = (str2len - best.levenshtein) / str2len;\n    return best;\n  }\n\n  getBestSubstringList(str1, str2, words1, threshold = 1) {\n    const str1len = str1.length;\n    const str2len = str2.length;\n    const result = [];\n    if (str1len <= str2len) {\n      const levenshtein = similarity(str1, str2, true);\n      const accuracy = (str2len - levenshtein) / str2len;\n      if (accuracy >= threshold) {\n        result.push({\n          start: 0,\n          end: str1len - 1,\n          len: str1len,\n          levenshtein,\n          accuracy,\n        });\n      }\n      return result;\n    }\n    const maxLevenshtein = str2len * (1 - threshold);\n    const wordPositions = words1 || this.getWordPositions(str1);\n    const wordPositionsLen = wordPositions.length;\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str3 = str1.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        const levenshtein = similarity(str3, str2, true);\n        const accuracy = (str2len - levenshtein) / str2len;\n        if (accuracy >= threshold) {\n          result.push({\n            start: wordPositions[i].start,\n            end: wordPositions[j].end,\n            len: wordPositions[j].end - wordPositions[i].start + 1,\n            levenshtein,\n            accuracy,\n          });\n        }\n        if (\n          str3.length - wordPositions[0].len >=\n          str2.length + maxLevenshtein\n        ) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  getRules(input) {\n    const allRules = input.nerRules;\n    if (!allRules) {\n      return [];\n    }\n    return allRules;\n  }\n\n  normalize(str) {\n    return str\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .toLowerCase();\n  }\n\n  buildRuleDict(rule) {\n    const dict = {};\n    const inverse = {};\n    for (let i = 0; i < rule.rules.length; i += 1) {\n      const current = rule.rules[i];\n      for (let j = 0; j < current.texts.length; j += 1) {\n        const source = current.texts[j];\n        const key = this.normalize(current.texts[j]);\n        if (!dict[key]) {\n          dict[key] = [];\n        }\n        dict[key].push(current);\n        inverse[key] = source;\n      }\n    }\n    rule.dict = dict;\n    rule.inverseDict = inverse;\n  }\n\n  getBestExact(srcText, words, rule) {\n    const text = this.normalize(srcText);\n    const wordPositions = words || this.getWordPositions(text);\n    const wordPositionsLen = wordPositions.length;\n    const result = [];\n    for (let i = 0; i < wordPositionsLen; i += 1) {\n      for (let j = i; j < wordPositionsLen; j += 1) {\n        const str = text.substring(\n          wordPositions[i].start,\n          wordPositions[j].end + 1\n        );\n        if (rule.dict[str]) {\n          const subrule = rule.dict[str];\n          for (let k = 0; k < subrule.length; k += 1) {\n            result.push({\n              accuracy: 1,\n              start: wordPositions[i].start,\n              end: wordPositions[j].end,\n              len: wordPositions[j].end - wordPositions[i].start + 1,\n              levenshtein: 0,\n              entity: rule.name,\n              type: rule.type,\n              option: subrule[k].option,\n              sourceText: rule.inverseDict[str],\n              utteranceText: srcText.substring(\n                wordPositions[i].start,\n                wordPositions[j].end + 1\n              ),\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  extractFromRule(text, rule, words, threshold) {\n    if (rule.type === 'enum') {\n      const edges = [];\n      if (threshold >= 1) {\n        if (!rule.dict) {\n          this.buildRuleDict(rule);\n        }\n        const newEdges = this.getBestExact(text, words, rule);\n        for (let i = 0; i < newEdges.length; i += 1) {\n          edges.push(newEdges[i]);\n        }\n      } else {\n        for (let i = 0; i < rule.rules.length; i += 1) {\n          const current = rule.rules[i];\n          if (current && current.option && Array.isArray(current.texts)) {\n            for (let j = 0; j < current.texts.length; j += 1) {\n              const newEdges = this.getBestSubstringList(\n                text,\n                current.texts[j],\n                words,\n                current.threshold || threshold\n              );\n              for (let k = 0; k < newEdges.length; k += 1) {\n                edges.push({\n                  ...newEdges[k],\n                  entity: rule.name,\n                  type: rule.type,\n                  option: rule.rules[i].option,\n                  sourceText: current.texts[j],\n                  utteranceText: text.substring(\n                    newEdges[k].start,\n                    newEdges[k].end + 1\n                  ),\n                });\n              }\n            }\n          }\n        }\n      }\n      return edges;\n    }\n    return [];\n  }\n\n  extract(srcInput) {\n    const input = srcInput;\n    const wordPositions = this.getWordPositions(input.text || input.utterance);\n    const rules = this.getRules(input);\n    const edges = input.edges || [];\n    for (let i = 0; i < rules.length; i += 1) {\n      const newEdges = this.extractFromRule(\n        input.text || input.utterance,\n        rules[i],\n        wordPositions,\n        input.threshold || 0.8\n      );\n      for (let j = 0; j < newEdges.length; j += 1) {\n        edges.push(newEdges[j]);\n      }\n    }\n    edges.sort((a, b) => a.start - b.start);\n    input.edges = reduceEdges(edges, false);\n    return input;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const extractor = this.container.get(`extract-enum-${locale}`) || this;\n    return extractor.extract(input);\n  }\n}\n\nmodule.exports = ExtractorEnum;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}