{"ast":null,"code":"/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst {\n  BaseStemmer\n} = require('@nlpjs/core');\nconst kuromoji = require('kuromoji');\nconst hepburn = require('./hepburn.json');\nconst keigo = require('./keigo.json');\n\n/**\n * Class for a Japanese Stemmer\n */\nclass StemmerJa extends BaseStemmer {\n  /**\n   * Constructor of the class\n   */\n  constructor(container) {\n    super(container);\n    this.name = 'stemmer-ja';\n    this.shiftToHiragana = '\\u3041'.charCodeAt(0) - '\\u30a1'.charCodeAt(0);\n  }\n\n  /**\n   * Promise to initialize the class and get the tokenizer\n   */\n  static classInit() {\n    return new Promise((resolve, reject) => {\n      if (StemmerJa.tokenizer) {\n        resolve();\n      } else {\n        let dicPath = path.join(__dirname, '../node_modules/kuromoji/dict');\n        if (!fs.existsSync(dicPath)) {\n          dicPath = path.join(__dirname, '../../../../node_modules/kuromoji/dict');\n          if (!fs.existsSync(dicPath)) {\n            dicPath = './node_modules/kuromoji/dict';\n          }\n        }\n        kuromoji.builder({\n          dicPath\n        }).build((err, tokenizer) => {\n          if (err) {\n            reject(err);\n          } else {\n            StemmerJa.tokenizer = tokenizer;\n            resolve();\n          }\n        });\n      }\n    });\n  }\n  init() {\n    return StemmerJa.classInit();\n  }\n\n  /**\n   * Indicates if the character is Hiragana\n   * @param {String} ch Character\n   */\n  isHiraganaChar(ch) {\n    return ch && ch >= '\\u3040' && ch <= '\\u309f';\n  }\n\n  /**\n   * Indicates if the character is Katakana\n   * @param {String} ch Character\n   */\n  isKatakanaChar(ch) {\n    return ch && ch >= '\\u30a0' && ch <= '\\u30ff';\n  }\n\n  /**\n   * Indicates if the character is Hiragana or Katakana\n   * @param {String} ch Character\n   */\n  isKanaChar(ch) {\n    return this.isHiraganaChar(ch) || this.isKatakanaChar(ch);\n  }\n\n  /**\n   * Indicates if the character is a Kanji\n   * @param {String} ch Character\n   */\n  isKanjiChar(ch) {\n    return ch >= '\\u4e00' && ch <= '\\u9fcf' || ch >= '\\uf900' && ch <= '\\ufaff' || ch >= '\\u3400' && ch <= '\\u4dbf';\n  }\n\n  /**\n   * Indicates if the character is Hiragana, Katakana or Kanji\n   * @param {String} ch Character\n   */\n  isJapaneseChar(ch) {\n    return this.isKanaChar(ch) || this.isKanjiChar(ch);\n  }\n\n  /**\n   * Indicates if a string contains Hiragana\n   * @param {String} str Input string.\n   */\n  hasHiragana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isHiraganaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Katakana\n   * @param {String} str Input string.\n   */\n  hasKatakana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKatakanaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Hiragana or Katakana\n   * @param {String} str Input string.\n   */\n  hasKana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKanaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Kanji\n   * @param {String} str Input string.\n   */\n  hasKanji(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKanjiChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Hiragana, Katakana or Kanji\n   * @param {String} str Input string.\n   */\n  hasJapanese(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isJapaneseChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Converts katakana characters to hiragana\n   * @param {String} str Input string\n   */\n  toHiragana(str) {\n    return [...str].map(ch => ch > '\\u30a0' && ch < '\\u30f7' ? String.fromCharCode(ch.charCodeAt(0) + this.shiftToHiragana) : ch).join('');\n  }\n\n  /**\n   * Converts hiragana characters to katakana\n   * @param {String} str Input string.\n   */\n  toKatakana(str) {\n    return [...str].map(ch => ch > '\\u3040' && ch < '\\u3097' ? String.fromCharCode(ch.charCodeAt(0) - this.shiftToHiragana) : ch).join('');\n  }\n\n  /**\n   * Converts a string to romaji.\n   * The string must contain hiragana or katakana, but kanjis are not converted.\n   * @param {String} srcStr Input string\n   */\n  toRomaji(srcStr) {\n    const reghatu = new RegExp(/(ん|ン)(?=あ|い|う|え|お|ア|イ|ウ|エ|オ|ぁ|ぃ|ぅ|ぇ|ぉ|ァ|ィ|ゥ|ェ|ォ|や|ゆ|よ|ヤ|ユ|ヨ|ゃ|ゅ|ょ|ャ|ュ|ョ)/g);\n    const indices = [];\n    let str = srcStr;\n    let match = reghatu.exec(str);\n    while (match !== null) {\n      indices.push(match.index + 1);\n      match = reghatu.exec(str);\n    }\n    if (indices.length !== 0) {\n      let mstr = '';\n      for (let i = 0; i < indices.length; i += 1) {\n        mstr += i === 0 ? `${str.slice(0, indices[i])}` : `${str.slice(indices[i - 1], indices[i])}`;\n      }\n      mstr += str.slice(indices[indices.length - 1]);\n      str = mstr;\n    }\n    let pnt = 0;\n    let result = '';\n    while (pnt <= str.length) {\n      let current = str.substring(pnt, pnt + 2);\n      current = hepburn[current] ? current : str.substring(pnt, pnt + 1);\n      result += hepburn[current] || current;\n      pnt += current.length || 1;\n    }\n    result = result.replace(/(っ|ッ)([bcdfghijklmnopqrstuvwyz])/gm, '$2$2');\n    result = result.replace(/cc/gm, 'tc');\n    result = result.replace(/っ|ッ/gm, 'tsu');\n    result = result.replace(/nm/gm, 'mm');\n    result = result.replace(/nb/gm, 'mb');\n    result = result.replace(/np/gm, 'mp');\n    result = result.replace(/aー/gm, 'ā');\n    result = result.replace(/iー/gm, 'ī');\n    result = result.replace(/uー/gm, 'ū');\n    result = result.replace(/eー/gm, 'ē');\n    result = result.replace(/oー/gm, 'ō');\n    return result;\n  }\n\n  /**\n   * Parse a text to obtain the japanese tokens\n   * @param {String} text Input string\n   */\n  parse(text) {\n    const tokens = StemmerJa.tokenizer.tokenize(text);\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (this.hasJapanese(token.surface_form)) {\n        if (!token.reading) {\n          token.reading = token.surface_form.split('').every(this.isKanaChar.bind(this)) ? this.toKatakana(token.surface_form) : token.surface_form;\n        } else if (this.hasHiragana(token.reading)) {\n          token.reading = this.toKatakana(token.reading);\n        }\n      } else {\n        token.reading = token.surface_form;\n      }\n    }\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      const prev = tokens[i - 1];\n      if (current.pos && current.pos === '助動詞' && (current.surface_form === 'う' || current.surface_form === 'ウ')) {\n        if (i - 1 >= 0 && prev.pos && prev.pos === '動詞') {\n          prev.surface_form += 'う';\n          if (prev.pronunciation) {\n            prev.pronunciation += 'ー';\n          } else {\n            prev.pronunciation = `${prev.reading}ー`;\n          }\n          prev.reading += 'ウ';\n          tokens.splice(i, 1);\n          i -= 1;\n        }\n      }\n    }\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      const next = tokens[i + 1];\n      if (current.pos && (current.pos === '動詞' || current.pos === '形容詞') && current.surface_form.length > 1 && (current.surface_form[current.surface_form.length - 1] === 'っ' || current.surface_form[current.surface_form.length - 1] === 'ッ')) {\n        if (i + 1 < tokens.length && next.pos && (next.pos === '動詞' || next.pos === '助動詞')) {\n          current.surface_form += next.surface_form;\n          if (current.pronunciation) {\n            current.pronunciation += next.pronunciation;\n          } else {\n            current.pronunciation = `${current.reading}${next.reading}`;\n          }\n          current.reading += next.reading;\n          tokens.splice(i + 1, 1);\n          i -= 1;\n        }\n      }\n    }\n    return tokens;\n  }\n\n  /**\n   * Convert a string to katakana\n   * @param {String} text Input text\n   */\n  convertToKatakana(text) {\n    return this.parse(text).map(token => token.reading).join(' ');\n  }\n\n  /**\n   * Convert a string to romaji\n   * @param {String} text Input text\n   */\n  convertToRomaji(text) {\n    return this.toRomaji(this.parse(text).map(token => token.reading).join(' '));\n  }\n\n  /**\n   * Indicates if the string is a number\n   * @param {String} str Input string\n   */\n  isNumber(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (!'0123456789'.includes(str[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  async stem(text, input) {\n    await this.init();\n    text = input.text;\n    let tokens;\n    const normalizeFormality = input.normalizeFormality === undefined ? true : input.normalizeFormality;\n    if (normalizeFormality) {\n      tokens = this.formalityLevel(text).informalTokens;\n    } else {\n      tokens = this.parse(text).map(token => token.reading);\n    }\n    tokens = tokens.map(token => token.replace(/[＿－・，、；：！？．。（）［］｛｝｢｣＠＊＼／＆＃％｀＾＋＜＝＞｜～≪≫─＄＂_\\-･,､;:!?.｡()[\\]{}「」@*/&#%`^+<=>|~«»$\"\\s]+/g, '')).filter(token => token !== '');\n    const removeNumbers = input.removeNumbers === undefined ? true : input.removeNumbers;\n    if (removeNumbers) {\n      tokens = tokens.filter(x => !this.isNumber(x));\n    }\n    const stemMinLength = input.stemMinLength === undefined ? 2 : input.stemMinLength;\n    tokens = tokens.filter(x => x.length >= stemMinLength);\n    return tokens;\n  }\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const stemmer = this.container.get(`stemmer-${locale}`) || this;\n    input.tokens = stemmer.stem(input.text || input.tokens.join(' '), input);\n    return input;\n  }\n\n  /**\n   * Find a keigo chain and returns the replacement and formality level.\n   * @param {String[]} tokens Input tokens\n   * @param {Number} pnt Current pointer in the chain\n   */\n  findKeigo(tokens, pnt) {\n    let node = keigo;\n    let result;\n    let currentPnt = pnt;\n    let currentToken = tokens[currentPnt];\n    while (currentToken && node[currentToken]) {\n      node = node[currentToken];\n      if (node.result) {\n        result = {\n          value: node.result.value,\n          keigo: node.result.keigo,\n          length: currentPnt - pnt + 1\n        };\n      }\n      currentPnt += 1;\n      currentToken = tokens[currentPnt];\n    }\n    return result;\n  }\n\n  // Informal\n  // Keigo (敬語) levels:\n  // - Teineigo (丁寧語) (polite)\n  // - Sonkeigo (尊敬語) (respectful: raise other status)\n  // - Kenjougo (謙譲語) (humble: lower own status)\n  formalityLevel(text) {\n    const tokens = this.parse(text).map(x => x.reading).filter(x => x && x !== ' ');\n    const informalTokens = [];\n    const counts = {\n      keigo: 0,\n      teineigo: 0,\n      sonkeigo: 0,\n      kenjougo: 0,\n      informal: 0\n    };\n    let pnt = 0;\n    while (pnt < tokens.length) {\n      const token = tokens[pnt];\n      const currentKeigo = this.findKeigo(tokens, pnt);\n      if (currentKeigo) {\n        if (currentKeigo.keigo !== 'dictionary') {\n          counts[currentKeigo.keigo] += 1;\n        }\n        for (let i = 0; i < currentKeigo.value.length; i += 1) {\n          informalTokens.push(currentKeigo.value[i]);\n        }\n        pnt += currentKeigo.length;\n      } else {\n        if (['ダ', 'ダッ', 'スル'].includes(token)) {\n          counts.informal += 1;\n          informalTokens.push(token);\n        } else if (token === 'ゴ') {\n          counts.keigo += 1;\n        } else {\n          informalTokens.push(token);\n        }\n        pnt += 1;\n      }\n    }\n    counts.keigo += counts.sonkeigo + counts.teineigo + counts.kenjougo;\n    return {\n      tokens,\n      informalTokens,\n      counts,\n      isKeigo: counts.keigo > 0\n    };\n  }\n}\nmodule.exports = StemmerJa;","map":{"version":3,"names":["fs","require","path","BaseStemmer","kuromoji","hepburn","keigo","StemmerJa","constructor","container","name","shiftToHiragana","charCodeAt","classInit","Promise","resolve","reject","tokenizer","dicPath","join","__dirname","existsSync","builder","build","err","init","isHiraganaChar","ch","isKatakanaChar","isKanaChar","isKanjiChar","isJapaneseChar","hasHiragana","str","i","length","hasKatakana","hasKana","hasKanji","hasJapanese","toHiragana","map","String","fromCharCode","toKatakana","toRomaji","srcStr","reghatu","RegExp","indices","match","exec","push","index","mstr","slice","pnt","result","current","substring","replace","parse","text","tokens","tokenize","token","surface_form","reading","split","every","bind","prev","pos","pronunciation","splice","next","convertToKatakana","convertToRomaji","isNumber","includes","stem","input","normalizeFormality","undefined","formalityLevel","informalTokens","filter","removeNumbers","x","stemMinLength","run","srcInput","locale","stemmer","get","findKeigo","node","currentPnt","currentToken","value","counts","teineigo","sonkeigo","kenjougo","informal","currentKeigo","isKeigo","module","exports"],"sources":["/home/sidahmed/Bureau/Cours_Master_1/S2/Web/Partie2/MoteurRecherche/moteur-rech/node_modules/@nlpjs/lang-ja/src/stemmer-ja.js"],"sourcesContent":["/*\n * Copyright (c) AXA Group Operations Spain S.A.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { BaseStemmer } = require('@nlpjs/core');\n\nconst kuromoji = require('kuromoji');\nconst hepburn = require('./hepburn.json');\nconst keigo = require('./keigo.json');\n\n/**\n * Class for a Japanese Stemmer\n */\nclass StemmerJa extends BaseStemmer {\n  /**\n   * Constructor of the class\n   */\n  constructor(container) {\n    super(container);\n    this.name = 'stemmer-ja';\n    this.shiftToHiragana = '\\u3041'.charCodeAt(0) - '\\u30a1'.charCodeAt(0);\n  }\n\n  /**\n   * Promise to initialize the class and get the tokenizer\n   */\n  static classInit() {\n    return new Promise((resolve, reject) => {\n      if (StemmerJa.tokenizer) {\n        resolve();\n      } else {\n        let dicPath = path.join(__dirname, '../node_modules/kuromoji/dict');\n        if (!fs.existsSync(dicPath)) {\n          dicPath = path.join(\n            __dirname,\n            '../../../../node_modules/kuromoji/dict'\n          );\n          if (!fs.existsSync(dicPath)) {\n            dicPath = './node_modules/kuromoji/dict';\n          }\n        }\n        kuromoji.builder({ dicPath }).build((err, tokenizer) => {\n          if (err) {\n            reject(err);\n          } else {\n            StemmerJa.tokenizer = tokenizer;\n            resolve();\n          }\n        });\n      }\n    });\n  }\n\n  init() {\n    return StemmerJa.classInit();\n  }\n\n  /**\n   * Indicates if the character is Hiragana\n   * @param {String} ch Character\n   */\n  isHiraganaChar(ch) {\n    return ch && ch >= '\\u3040' && ch <= '\\u309f';\n  }\n\n  /**\n   * Indicates if the character is Katakana\n   * @param {String} ch Character\n   */\n  isKatakanaChar(ch) {\n    return ch && ch >= '\\u30a0' && ch <= '\\u30ff';\n  }\n\n  /**\n   * Indicates if the character is Hiragana or Katakana\n   * @param {String} ch Character\n   */\n  isKanaChar(ch) {\n    return this.isHiraganaChar(ch) || this.isKatakanaChar(ch);\n  }\n\n  /**\n   * Indicates if the character is a Kanji\n   * @param {String} ch Character\n   */\n  isKanjiChar(ch) {\n    return (\n      (ch >= '\\u4e00' && ch <= '\\u9fcf') ||\n      (ch >= '\\uf900' && ch <= '\\ufaff') ||\n      (ch >= '\\u3400' && ch <= '\\u4dbf')\n    );\n  }\n\n  /**\n   * Indicates if the character is Hiragana, Katakana or Kanji\n   * @param {String} ch Character\n   */\n  isJapaneseChar(ch) {\n    return this.isKanaChar(ch) || this.isKanjiChar(ch);\n  }\n\n  /**\n   * Indicates if a string contains Hiragana\n   * @param {String} str Input string.\n   */\n  hasHiragana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isHiraganaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Katakana\n   * @param {String} str Input string.\n   */\n  hasKatakana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKatakanaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Hiragana or Katakana\n   * @param {String} str Input string.\n   */\n  hasKana(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKanaChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Kanji\n   * @param {String} str Input string.\n   */\n  hasKanji(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isKanjiChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Indicates if a string contains Hiragana, Katakana or Kanji\n   * @param {String} str Input string.\n   */\n  hasJapanese(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (this.isJapaneseChar(str[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Converts katakana characters to hiragana\n   * @param {String} str Input string\n   */\n  toHiragana(str) {\n    return [...str]\n      .map((ch) =>\n        ch > '\\u30a0' && ch < '\\u30f7'\n          ? String.fromCharCode(ch.charCodeAt(0) + this.shiftToHiragana)\n          : ch\n      )\n      .join('');\n  }\n\n  /**\n   * Converts hiragana characters to katakana\n   * @param {String} str Input string.\n   */\n  toKatakana(str) {\n    return [...str]\n      .map((ch) =>\n        ch > '\\u3040' && ch < '\\u3097'\n          ? String.fromCharCode(ch.charCodeAt(0) - this.shiftToHiragana)\n          : ch\n      )\n      .join('');\n  }\n\n  /**\n   * Converts a string to romaji.\n   * The string must contain hiragana or katakana, but kanjis are not converted.\n   * @param {String} srcStr Input string\n   */\n  toRomaji(srcStr) {\n    const reghatu = new RegExp(\n      /(ん|ン)(?=あ|い|う|え|お|ア|イ|ウ|エ|オ|ぁ|ぃ|ぅ|ぇ|ぉ|ァ|ィ|ゥ|ェ|ォ|や|ゆ|よ|ヤ|ユ|ヨ|ゃ|ゅ|ょ|ャ|ュ|ョ)/g\n    );\n    const indices = [];\n    let str = srcStr;\n    let match = reghatu.exec(str);\n    while (match !== null) {\n      indices.push(match.index + 1);\n      match = reghatu.exec(str);\n    }\n    if (indices.length !== 0) {\n      let mstr = '';\n      for (let i = 0; i < indices.length; i += 1) {\n        mstr +=\n          i === 0\n            ? `${str.slice(0, indices[i])}`\n            : `${str.slice(indices[i - 1], indices[i])}`;\n      }\n      mstr += str.slice(indices[indices.length - 1]);\n      str = mstr;\n    }\n    let pnt = 0;\n    let result = '';\n    while (pnt <= str.length) {\n      let current = str.substring(pnt, pnt + 2);\n      current = hepburn[current] ? current : str.substring(pnt, pnt + 1);\n      result += hepburn[current] || current;\n      pnt += current.length || 1;\n    }\n    result = result.replace(/(っ|ッ)([bcdfghijklmnopqrstuvwyz])/gm, '$2$2');\n    result = result.replace(/cc/gm, 'tc');\n    result = result.replace(/っ|ッ/gm, 'tsu');\n    result = result.replace(/nm/gm, 'mm');\n    result = result.replace(/nb/gm, 'mb');\n    result = result.replace(/np/gm, 'mp');\n    result = result.replace(/aー/gm, 'ā');\n    result = result.replace(/iー/gm, 'ī');\n    result = result.replace(/uー/gm, 'ū');\n    result = result.replace(/eー/gm, 'ē');\n    result = result.replace(/oー/gm, 'ō');\n    return result;\n  }\n\n  /**\n   * Parse a text to obtain the japanese tokens\n   * @param {String} text Input string\n   */\n  parse(text) {\n    const tokens = StemmerJa.tokenizer.tokenize(text);\n    for (let i = 0; i < tokens.length; i += 1) {\n      const token = tokens[i];\n      if (this.hasJapanese(token.surface_form)) {\n        if (!token.reading) {\n          token.reading = token.surface_form\n            .split('')\n            .every(this.isKanaChar.bind(this))\n            ? this.toKatakana(token.surface_form)\n            : token.surface_form;\n        } else if (this.hasHiragana(token.reading)) {\n          token.reading = this.toKatakana(token.reading);\n        }\n      } else {\n        token.reading = token.surface_form;\n      }\n    }\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      const prev = tokens[i - 1];\n      if (\n        current.pos &&\n        current.pos === '助動詞' &&\n        (current.surface_form === 'う' || current.surface_form === 'ウ')\n      ) {\n        if (i - 1 >= 0 && prev.pos && prev.pos === '動詞') {\n          prev.surface_form += 'う';\n          if (prev.pronunciation) {\n            prev.pronunciation += 'ー';\n          } else {\n            prev.pronunciation = `${prev.reading}ー`;\n          }\n          prev.reading += 'ウ';\n          tokens.splice(i, 1);\n          i -= 1;\n        }\n      }\n    }\n    for (let i = 0; i < tokens.length; i += 1) {\n      const current = tokens[i];\n      const next = tokens[i + 1];\n      if (\n        current.pos &&\n        (current.pos === '動詞' || current.pos === '形容詞') &&\n        current.surface_form.length > 1 &&\n        (current.surface_form[current.surface_form.length - 1] === 'っ' ||\n          current.surface_form[current.surface_form.length - 1] === 'ッ')\n      ) {\n        if (\n          i + 1 < tokens.length &&\n          next.pos &&\n          (next.pos === '動詞' || next.pos === '助動詞')\n        ) {\n          current.surface_form += next.surface_form;\n          if (current.pronunciation) {\n            current.pronunciation += next.pronunciation;\n          } else {\n            current.pronunciation = `${current.reading}${next.reading}`;\n          }\n          current.reading += next.reading;\n          tokens.splice(i + 1, 1);\n          i -= 1;\n        }\n      }\n    }\n    return tokens;\n  }\n\n  /**\n   * Convert a string to katakana\n   * @param {String} text Input text\n   */\n  convertToKatakana(text) {\n    return this.parse(text)\n      .map((token) => token.reading)\n      .join(' ');\n  }\n\n  /**\n   * Convert a string to romaji\n   * @param {String} text Input text\n   */\n  convertToRomaji(text) {\n    return this.toRomaji(\n      this.parse(text)\n        .map((token) => token.reading)\n        .join(' ')\n    );\n  }\n\n  /**\n   * Indicates if the string is a number\n   * @param {String} str Input string\n   */\n  isNumber(str) {\n    for (let i = 0; i < str.length; i += 1) {\n      if (!'0123456789'.includes(str[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  async stem(text, input) {\n    await this.init();\n    text = input.text;\n    let tokens;\n    const normalizeFormality =\n      input.normalizeFormality === undefined ? true : input.normalizeFormality;\n    if (normalizeFormality) {\n      tokens = this.formalityLevel(text).informalTokens;\n    } else {\n      tokens = this.parse(text).map((token) => token.reading);\n    }\n    tokens = tokens\n      .map((token) =>\n        token.replace(\n          /[＿－・，、；：！？．。（）［］｛｝｢｣＠＊＼／＆＃％｀＾＋＜＝＞｜～≪≫─＄＂_\\-･,､;:!?.｡()[\\]{}「」@*/&#%`^+<=>|~«»$\"\\s]+/g,\n          ''\n        )\n      )\n      .filter((token) => token !== '');\n    const removeNumbers =\n      input.removeNumbers === undefined ? true : input.removeNumbers;\n    if (removeNumbers) {\n      tokens = tokens.filter((x) => !this.isNumber(x));\n    }\n    const stemMinLength =\n      input.stemMinLength === undefined ? 2 : input.stemMinLength;\n    tokens = tokens.filter((x) => x.length >= stemMinLength);\n    return tokens;\n  }\n\n  run(srcInput) {\n    const input = srcInput;\n    const locale = input.locale || 'en';\n    const stemmer = this.container.get(`stemmer-${locale}`) || this;\n    input.tokens = stemmer.stem(input.text || input.tokens.join(' '), input);\n    return input;\n  }\n\n  /**\n   * Find a keigo chain and returns the replacement and formality level.\n   * @param {String[]} tokens Input tokens\n   * @param {Number} pnt Current pointer in the chain\n   */\n  findKeigo(tokens, pnt) {\n    let node = keigo;\n    let result;\n    let currentPnt = pnt;\n    let currentToken = tokens[currentPnt];\n    while (currentToken && node[currentToken]) {\n      node = node[currentToken];\n      if (node.result) {\n        result = {\n          value: node.result.value,\n          keigo: node.result.keigo,\n          length: currentPnt - pnt + 1,\n        };\n      }\n      currentPnt += 1;\n      currentToken = tokens[currentPnt];\n    }\n    return result;\n  }\n\n  // Informal\n  // Keigo (敬語) levels:\n  // - Teineigo (丁寧語) (polite)\n  // - Sonkeigo (尊敬語) (respectful: raise other status)\n  // - Kenjougo (謙譲語) (humble: lower own status)\n  formalityLevel(text) {\n    const tokens = this.parse(text)\n      .map((x) => x.reading)\n      .filter((x) => x && x !== ' ');\n    const informalTokens = [];\n    const counts = {\n      keigo: 0,\n      teineigo: 0,\n      sonkeigo: 0,\n      kenjougo: 0,\n      informal: 0,\n    };\n    let pnt = 0;\n    while (pnt < tokens.length) {\n      const token = tokens[pnt];\n      const currentKeigo = this.findKeigo(tokens, pnt);\n      if (currentKeigo) {\n        if (currentKeigo.keigo !== 'dictionary') {\n          counts[currentKeigo.keigo] += 1;\n        }\n        for (let i = 0; i < currentKeigo.value.length; i += 1) {\n          informalTokens.push(currentKeigo.value[i]);\n        }\n        pnt += currentKeigo.length;\n      } else {\n        if (['ダ', 'ダッ', 'スル'].includes(token)) {\n          counts.informal += 1;\n          informalTokens.push(token);\n        } else if (token === 'ゴ') {\n          counts.keigo += 1;\n        } else {\n          informalTokens.push(token);\n        }\n        pnt += 1;\n      }\n    }\n    counts.keigo += counts.sonkeigo + counts.teineigo + counts.kenjougo;\n    return {\n      tokens,\n      informalTokens,\n      counts,\n      isKeigo: counts.keigo > 0,\n    };\n  }\n}\n\nmodule.exports = StemmerJa;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}